= 良いインフラの作り方

//imagetalkl[mai_nutoral]{
さて、ここまでで「良いプロジェクトの作り方」、「良いプログラムの作り方」、「良い開発環境の作り方」とは何かを話してきたけど、最後にもう一つ、「良いインフラの作り方」について話をしよう。
//}

//imagetalkr[akina_nutoral]{
インフラって言葉はもともと建築関係の言葉だと思ってました。ネットワークとかミドルウェアの設定のことを言うんですよね。
//}

//imagetalkl[mai_nutoral]{
そうだね。わたしも同じ感覚だったなぁ。まぁ、IT業界のプロジェクトマネジメントのノウハウも製造業や建築業から来てる部分が多いし、そういう流れの一端なんじゃないかな。
//}

//imagetalkr[akina_nutoral]{
なるほど、意外と建築とか製造業とかと関係が深いんですね。
//}


== アーキテクトとインフラ

//imagetalkl[mai_nutoral]{
インフラの大まかな設計をする役職のことをアーキテクトって言う。これも建築業から来てるね。
//}


//imagetalkr[akina_nutoral]{
おぉ、アーキテクト、聞いたことあります。あれ、アーキテクチャだっけ？
//}

//imagetalkl[mai_nutoral]{
アーキテクチャは大まかな設計自体のことを言うね。
//}

//imagetalkr[akina_nutoral]{
そうなんですね。アーキテクトってなんだか偉い人のイメージがあります。
//}

//imagetalkl[mai_nutoral]{
偉いっていうより上流工程を担当することが多いね。ただ、このアーキテクチャ設計が間違ってたりするとプロジェクトへのダメージが非常に大きい。責任が重いから偉いのは確かにそうなの・・・かな？
//}

//imagetalkr[akina_nutoral]{
正確な仕事をお願いしたいですね。
//}


//imagetalkl[mai_tohoho]{
正確っていうのも難しい基準だとは思うけどね。アーキテクチャ設計自体はお客さんの粗削りな要求以外何にもない状態から始まるし、その要求が無茶なこと言ってることもあるからねぇ。
//}


//imagetalkr[akina_nutoral]{
大変だ・・・。
//}

//imagetalkl[mai_nutoral]{
まぁ、今であれば様々なクラウドのサービスや稼働様態を把握して良いものを選んでいくスキルが求められるね。
//}

//imagetalkr[akina_nutoral]{
となると、かなり専門性の高い仕事ですね。
//}

//imagetalkl[mai_tohoho]{
そうだね。さすがに高給取りな職でもいいかもしれない専門性の高さだ。ただ、IT業界の一部の会社では「プロジェクトマネージャーでもプログラマーでもインフラエンジニアでもないけど技術にうるさい人」程度の扱いしか受けてなかったりするから不遇な場合もある。
//}

//imagetalkr[akina_ugee]{
地獄だ・・・どうして・・・アーキテクトさんはこんなに頑張ってるのに。
//}

//imagetalkl[mai_ahaha]{
あっはは！まぁ評価してくれる会社に転職してるんじゃない？仕事できる人なら職場を選ぶ決断力も肝も据わってそうだね！
//}

//imagetalkr[akina_nutoral]{
そうなんですかね・・・
//}

//imagetalkl[mai_nutoral]{
さて、話がそれちゃったけど本題はインフラの話だ。インフラの大まかな設計はアーキテクチャといって、アーキテクトが設計する。インフラエンジニアの人たちはその大枠の中で個々のサービスを実現させるためのネットワークやサーバー設定を行う。
//}

//imagetalkr[akina_ettu]{
ネットワークの設計って、アーキテクチャ設計には入らないんですか？
//}

//imagetalkl[mai_nutoral]{
そう、状況にもよるけどね。例えばだけど特定領域は社内ネットワークで動いて、一部の処理だけ外部ネットワークと接続する形をとったりする。しかも、データの管理は両方のネットワークからクラウドのDBに繋げたりって感じで、個々のネットワークだけでは表現できないものをアーキテクチャとして設計するね。個々のネットワークの内部をどう作るかというあたりからがインフラエンジニアの仕事だ。
//}

//imagetalkr[akina_nutoral]{
なるほど、そんなに規模が大きいものまで設計するんですね。
//}


//imagetalkl[mai_nutoral]{
まぁアーキテクトから出るのは大雑把な指示になることが多いから、現場のエンジニアたちとは綿密にコミュニケーションを取ることが大事だね。とくにインフラエンジニアたちは設計書と実装が厳密に結びついてることがそのまま品質につながるから、漏れることなく情報を連携しないといけないね。ちなみにこれからインフラ周りの細かい話をしていくんだけど、あきなちゃんはこのあたりの話は前のプロジェクトで触れたかな？
//}

//imagetalkr[akina_nutoral]{
うぅ・・・正直あんまり触れなかったので、研修の時の知識ぐらいしかありません。
//}

//imagetalkl[mai_niko]{
OKじゃあ復習がてら、じっくり見ていこう！
//}

//imagetalkr[akina_niko]{
お願いします！
//}


== ITインフラの基礎知識


//imagetalkl[mai_nutoral]{
それじゃあITインフラの基礎知識のおさらいといこう。とてもシンプルだけどこの3点を押さえよう。
アドレスとポート
ルータ
ドメインとDNS
あきなちゃんはこの3つ、ちゃんと覚えてる？
//}

//imagetalkr[akina_nutoral]{
覚えてる・・・と言いたいところですが、完璧ではないかもしれません。
//}

//imagetalkl[mai_niko]{
OK、これも一つ一つ見ていこう。
//}

=== アドレスとポート

//imagetalkl[mai_nutoral]{
まず最初にアドレスとポートだけど、アドレスは住所にたとえられるね。
//}

//imagetalkr[akina_nutoral]{
アドレスはなんとなくイメージできますね。でも、ポートってうまくイメージできないんですけど・・・
//}

//imagetalkl[mai_nutoral]{
たとえるなら空港の搭乗口がいいかもね。
//}

//imagetalkr[akina_ooo]{
搭乗口ですか。
//}

//imagetalkl[mai_nutoral]{
空港の搭乗口って何個もあるよね？
//}

//imagetalkr[akina_nutoral]{
はい。
//}

//imagetalkl[mai_nutoral]{
その搭乗口の何番ゲートっていうのがポートの番号に相当すると思ってもらっていい。ゲート番号は異なるけど、空港の中に入っていくっていうのは変わらない。コンピュータも外部との通信の経路を用意していて、その経路番号ごとに通信可否を管理しているんだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、空港名や住所がアドレスで、そこにアクセスするためのゲート番号がポート番号なんですね。
//}


//imagetalkl[mai_nutoral]{
あと、ポート番号は用途ごとによく使われるものが慣習的に決まっている。例えばHTTP接続の場合は80番、SSH接続の場合は22番など、専用ゲートといってもいい予約された番号があるんだ。
//}

//imagetalkr[akina_nutoral]{
専用ゲートですか。決まってると良いことがあるんですか？
//}

//imagetalkl[mai_nutoral]{
基本的にはすべてのゲートを閉じていて、あらかじめ用途ごとに必要なゲートのみを開けるのが通例だね。そのために専用ゲートの慣習番号があるね。
//}

//imagetalkr[akina_nutoral]{
なるほど！明示的に指定したものしか通さないんですね。
//}


//imagetalkl[mai_nutoral]{
予期してないところから通信なんて来たらびっくりしちゃうよね。ちなみに無造作に空いているポートがないかを総当たりで検索してターゲットのサーバーへ侵入を試みる「ポートスキャン攻撃」ってハッキング手段が存在する。
//}

//imagetalkr[akina_nutoral]{
ポートの検索自体が「攻撃」なんですね。
//}

//imagetalkl[mai_nutoral]{
実際、攻撃する意図が無ければそんなことしないしね。さらに言うと、ポートスキャン攻撃を仕掛けてきたコンピューターからの通信を遮断する防御方法も考案されてるね。
//}

//imagetalkr[akina_ugee]{
これはよくわからないとか言ってられない話になってきました・・・
//}

//imagetalkl[mai_nutoral]{
まぁセキュリティに関してはまた後で話すから、今はこのぐらいにしておこう。
//}

=== ルーター

//imagetalkl[mai_nutoral]{
つぎはルーターだ。アドレスを住所にたとえたことを踏まえれば多くの住所を把握している郵便局ぐらいに考えておこうか。
//}

//imagetalkr[akina_nutoral]{
郵便局ですか。
//}

//imagetalkl[mai_nutoral]{
郵便局はいろんな町ごとにあるよね？
//}

//imagetalkr[akina_nutoral]{
ありますね。市とか区とか、もっと細かい範囲にもあると思います。
//}

//imagetalkl[mai_nutoral]{
北海道の郵便局が沖縄の住所に詳しい必要はないよね。
//}

//imagetalkr[akina_nutoral]{
それは・・・そうですね。沖縄の郵便局が詳しければ事足りるかもしれません。
//}

//imagetalkl[mai_nutoral]{
ルーターの役割も似てるんだ。特定のネットワーク内でアドレスを管理するのがルーターで、ルーターは自分が管理するネットワーク内のアドレスに詳しければいい。
//}

//imagetalkr[akina_nutoral]{
なるほど、特定のネットワークの案内役なんですね。
//}

//imagetalkl[mai_nutoral]{
そう、シンプルに考えればね。で、アドレスの実際の値なんだけど「192.168.0.1」みたいなピリオドで区切られた4つの値の組み合わせで表現されるね。
//}

//imagetalkr[akina_ettu]{
あれ、「google.com」みたいなやつとは違うんですか？
//}

//imagetalkl[mai_nutoral]{
そう、別物だ、ちなみにこの数字のアドレス表記はIPv4っていう種類の表し方だね。IPv6っていう新バージョンの表し方もあるけど今のところはIPv4の表記になれた方がいいね。この数字による表記がアドレスの実態で「google.com」みたいな文字列の表記はドメインって言われるんだ。
//}

=== ドメインとDNS

//imagetalkr[akina_nutoral]{
ドメイン・・・ですか。名前の響きは聞いたことありますが、それがアドレスの代わりになるんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね、順を追って説明しよう。まず、アドレスがあって、PCはそのアドレスを頼りに通信を行うんだけど、そのアドレスを人間が呼んでもわかりやすい文字列で表記したいって需要が生まれてきたんだ。その需要に答えるために考えられたのがドメイン名っていう文字列表記の方法と、ドメイン名とアドレスを照らし合わせるドメインネームサービス(DNS)ってものが生み出されたんだ。
//}

//imagetalkr[akina_nutoral]{
DNS・・・その響きも聞いたことあります。
//}

//imagetalkl[mai_nutoral]{
このDNSはドメイン名を聞くと実態のアドレスを教えてくれる存在なんだけど、このDNSサービスはインターネットのどこからでもアクセスできる必要がある。
//}

//imagetalkr[akina_nutoral]{
まぁ自分のPCから「google.com」にアクセスできなきゃ困りますもんね。
//}

//imagetalkl[mai_nutoral]{
そうそう。で、だからこそインターネットのあらゆる場所からアクセスするために、「とりあえずアクセスしに行くDNSサーバー」が取り決められている。
//}

//imagetalkr[akina_niko]{
なるほど!いくつかの「とりあえずアクセスしに行くDNSサーバー」にドメイン名を聞けばどこかしらからたどり着けるはずって話ですね。
//}

//imagetalkl[mai_niko]{
そのとおり！ただ、この「とりあえずアクセスしに行くDNSサーバー」は取り決め上勝手にどんどん増やすことはできなくて、一部のサーバーに限られている。そしてこの「とりあえずアクセスしに行くDNSサーバー」は有料であったり何かしらの登録を受け付ける形で自らが案内すべきドメインを蓄積していくんだ。
//}

//imagetalkr[akina_ettu]{
え、じゃあ自分の好きなドメインを登録するのは有料だったりするんですか？
//}

//imagetalkl[mai_nutoral]{
いくつかのDNSサービスは無料の物があって、逆に無料であるからこそ選択肢が少なくてユーザー間で有名だね。「お名前ドットコム」や「free.com」などが有名だ。
//}

//imagetalkr[akina_nutoral]{
あ、良かった。無料もあるんですね。
//}

//imagetalkl[mai_nutoral]{
無料な分、ドメイン名の一部に制約を受けたりするね。ドメインの終わりの「○○.com」とか「○○.jp」とかのドメイン名は無料で取れないケースが多いね。ドメイン名自体が他とかぶっちゃいけないっていう制約もあるから有料であっても完全に自由な選択ができるわけでもないけどね。
//}

//imagetalkr[akina_nutoral]{
なるほど。かぶっちゃいけないのが特徴なんですね。あれ、じゃぁみんなが取りたいようなドメイン名は高かったりするんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。やっぱり見栄えのいいものはDNSサービスの料金設定次第で高かったりするね。しかも、まるかぶりはできないから基本的には取ったもん勝ちだね。
//}

//imagetalkr[akina_nutoral]{
取ったものがちですか。なんだかちょっと意外な闘争の片鱗を感じますね。
//}

//imagetalkl[mai_nutoral]{
案外身近なんだよね。プログラムの開発にどっぷりつかってると忘れそうになるけどね。
//}

===[mycolumn]おススメ書籍

図解即戦力 ネットワークのしくみと技術がこれ1冊でしっかりわかる本

//image[zukainetwork][][scale=0.5]

出版社  :  技術評論社

発売日  :  2022/5/18

ISBN-10  :  4297127938

ISBN-13  :  978-4297127930

おすすめポイント:ネットワークに関わる単語を個別に図表を添えて丁寧に解説している。章分けと解説順序によって、一から読んでも理解できるし、手帳のごとく思い出したいときに開くのにも適している。また、クラウドや無線通信のしくみの解説もありシンプルなインフラ知識以上の周辺知識を獲得できる。



===[/mycolumn]


== クラスター化とKurbernetes

//imagetalkl[mai_nutoral]{
さて、ここまででITインフラの基礎知識をさらって見たわけだけど、この知識を使って覚えておきたいことがある。コンテナオーケストレーションツール、Kubernetesを使ったサーバーのクラスター化だ。
//}

//imagetalkr[akina_nutoral]{
あ、また出てきましたね。Kubernetes
//}

//imagetalkl[mai_nutoral]{
複数ホスト上にコンテナを立てて連携できるツールとして紹介したね。このKubernetesを使って複数コンテナで構成したルーターやDNS機能も含めた仮想ネットワークを、複数ホスト上に構築して負荷分散を行う構成を作ることができる。
//}

//imagetalkr[akina_nutoral]{
コンテナだけじゃなくて仮想のネットワークを作れるのはすごいですね。
//}

//imagetalkl[mai_nutoral]{
本当に便利だね。仮想ネットワークで構築したサービスを複数ホスト上に構成することで、一つのホストマシンが障害等でダウンしてしまったとしても、他のホストが生きてさえいれば継続してサービスを稼働させることができる。サービスの耐障害性という点でも信頼できる構成を作ることができる。これをサービスのクラスター化と呼ぶんだ。
//}

//imagetalkr[akina_ooo]{
クラスター化はよく聞いてましたけど、ここまで準備するものなんですね。
//}

//imagetalkl[mai_nutoral]{
そうだね。便利な分、構築には知識と時間が必要だ。ただ、このKubernetesを使った構成は一度作ってしまえば再構築が非常に簡単にできる。設定を記述したファイルといくつかのコマンドだけで環境の再現ができるんだ。このような環境構成を設定ファイルなどに明示的に記載して、ツールなどで再現可能な環境構成を作る働きかけをInfrastructure as Code(IaC)と呼ぶんだ。
//}

//imagetalkr[akina_ooo]{
それも聞いたことあります！なんとなく遠いものに思って聞き流してましたけどこういう物のことを言うんですね。いや・・・うーん、やっぱり遠い・・・。
//}

//imagetalkl[mai_ahaha]{
あはは！まぁこのあたりまで来るとアプリケーション系のエンジニアはやっぱり分野が違うように思うよね！でもこういう技術があることは覚えておくと後々絶対役に立つよ！
//}

//imagetalkr[akina_niko]{
わかりました。覚えておきます！
//}

== クラウド化

//imagetalkl[mai_nutoral]{
さて、Kubernetesによるクラスター化やIaCについて触れてきたけど、そろそろ覚えてもいいころ合いの話題が一つある。「クラウド化」だ。
//}

//imagetalkr[akina_nutoral]{
ここまできてやっとクラウドですか！遠いなぁ。
//}

//imagetalkl[mai_nutoral]{
そうだね。言ってみればクラウドってものは今までの技術の集大成、専門家が多くの時間と資金をかけて作り上げた仮想インフラだ。
//}

//imagetalkr[akina_nutoral]{
仮想インフラってことはどこかに物理マシンが存在するんですか？
//}

//imagetalkl[mai_nutoral]{
存在するよ。と言っても大手のクラウドはセキュリティの観点からどこに物理マシンがあるかは公表しないけど、巨大なデータセンターを保持していてそこの物理マシンを仮想インフラに組みなおしてクラウドサービスを展開している。
//}

//imagetalkr[akina_nutoral]{
Kubernetesの話で複数ホストの話がありましたけど、データセンターも複数あるんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。世界中にデータセンターを配置してどこで自然災害や戦争が起きてもクラウドサービス自体は動き続けるように組み上げられてるね。
//}

//imagetalkr[akina_ooo]{
おぉ・・・すごい規模ですね。
//}

//imagetalkl[mai_nutoral]{
やっぱりその分専門業者しかクラウドサービスを展開できないけどね。必要な元手が大きすぎる。Amazon、Google、Microsoftどれも超巨大企業だ。
//}

//imagetalkr[akina_nutoral]{
でも、なんで今のタイミングでクラウドの話なんですか？前フリが長いような。
//}

//imagetalkl[mai_nutoral]{
必要なんだよなぁ、これが。あきなちゃんはクラウドは何か触ったことある？
//}

//imagetalkr[akina_nutoral]{
いや、ないです。
//}

//imagetalkl[mai_nutoral]{
OK、クラウドサービスを使う際には最初はWEBブラウザからアクセスすることになる。WEBページでGUIが構成されてるからね。んで、画面の指示に従って操作していくとブラウザ操作だけでコンテナ化されたマシンを借りることができる。
//}

//imagetalkr[akina_ooo]{
ブラウザ操作だけでですか！すごいですね。
//}

//imagetalkl[mai_nutoral]{
便利な時代になったよね。でも結局、ブラウザ経由でDockerのような仮想コンテナツールを操作してるようなものなんだよね。
//}

//imagetalkr[akina_nutoral]{
なるほど、そう考えたらシンプルですね。クラウドって聞くとなんとなくすごいって思ってましたけど、案外身近ですね。
//}

//imagetalkl[mai_niko]{
まぁそれを実現するまでの裏方だったり洗練された画面操作方法の作りだったり、中々まねできないものも多いけど、仕組み自体はこれまでの知識で大方理解できるね！あきなちゃんも成長したね！えらい！
//}

//imagetalkr[akina_iyasono]{
急に褒められても・・・いや、ありがとうございます。もっと勉強してお役に立てるように頑張ります！
//}


== サーバーレス化

//imagetalkl[mai_nutoral]{
クラウド化の威力と恩恵を学んだところで、クラウドサービスの最大の恩恵、サーバレス化についても学んでおこう。
//}

//imagetalkr[akina_ettu]{
サーバーレスって、名前は聞きますけどどういうことですか？クラウドでサーバーを借りるはずなのに「レス」って「無い」って意味ですよね？
//}

//imagetalkl[mai_nutoral]{
覚え方的には、「サーバーのことを気にかける必要が無い」って方がいいね。使う側はアプリケーション用のコードを記述してサービスに登録するだけで、サーバーの稼働状態を気にすることなくアプリケーションを稼働させ続けることができる。
//}

//imagetalkr[akina_ettu]{
サーバーの稼働状態を気にしないでアプリケーションが動かせる？？最強じゃないですか！
//}

//imagetalkl[mai_niko]{
まさにクラウドサービスの粋、マグロでいうとトロの部分だよね！コードを書くことを本業とする人たちにとってはまさに、インフラを気にしなくていい実行環境だ。もちろんコードの書き方に特徴や制限があるけどね。
//}

//imagetalkr[akina_ooo]{
それでも、魅力的すぎます。
//}


//imagetalkl[mai_nutoral]{
そうだよね、実際サーバーレスサービスは多くのクラウドで利用されていて、サーバーを1台も借りてないけどサーバーレスアプリはいくつか運用しているっていうところもあるね。
//}

//imagetalkr[akina_nutoral]{
そんな使い方をするケースもあるんですね。サーバーを一つ立ち上げるのに苦労する時代とは大違いですね。
//}

//imagetalkl[mai_nutoral]{
今の日本でもそういう仕事をしているところはまだまだあるから過渡期って感じだけどね。何か制約があるならまだしも「分からないから」「使ったことがないから」なんて理由で敬遠してちゃいけないね。
//}

//imagetalkr[akina_ooo]{
むむむ・・・頑張って覚えないとですね。
//}


//imagetalkl[mai_ahaha]{
無理しない程度にね！あ、そうそうサーバーレスサービスを使うにあたってコード側で気をつけなきゃいけないことがある。それはAPIベースの設計に従うってことだ。WEB APIしかり、コードを機能ごとに分離する設計が必要になるんだ。
//}

//imagetalkr[akina_hee]{
なるほど、細かい機能ごとにコードが分離されている方がテスト容易性や再利用性が高いんですよね！
//}

//imagetalkl[mai_niko]{
そうそう！そしてその再利用性の部分に強くフォーカスした考えが「マイクロサービス」と言う設計思想につながっているんだ。
//}



== マイクロサービス


//imagetalkr[akina_nutoral]{
マイクロサービスですか。これも名前だけ聞いたことがあるってだけですね・・・。
//}


//imagetalkl[mai_nutoral]{
マイクロサービスはAPIベース設計とシナジーの高い考え方なんだけど、特定の機能をWEB APIやサーバーレス化したサービスとして分離して、開発の焦点を細かい単位に分解して複雑なシステムの開発を避ける設計思想だね。アーキテクチャレベルの考え方が必要だから「マイクロサービスアーキテクチャ」なんて呼ばれることも多いね。
//}

//imagetalkr[akina_nutoral]{
アーキテクチャ単位の考え方になるんですね。
//}

//imagetalkl[mai_nutoral]{
言ってみれば特定の機能だけ切り出して別サーバーに乗せるようなものだからね。それが複数のサブシステム間で呼べるように設計するには、やっぱりアーキテクトが情報整理をしなくちゃいけないね。
//}

//imagetalkr[akina_nutoral]{
なるほど。でもなんだかコードとか機能単位の考え方なのか、アーキテクチャ単位の考え方なのか、ごっちゃになってしまいそうです。
//}

//imagetalkl[mai_nutoral]{
実際日本でこのアーキテクチャの浸透が遅れてるのはそこの分業の制度のかみ合わなさが大きいと思うね。設計ができてコードを考えられてアーキテクチャ設計をできる人が少なすぎる。
//}

//imagetalkr[akina_nutoral]{
たしかにそこまでできたら本当になんでも屋ですね。
//}


//imagetalkl[mai_tohoho]{
会社で育ってもどんどん別の会社に行っちゃいそうだしね。まぁ、なんにせよマイクロサービスアーキテクチャでものを考えられる体制があれば様々なシーンで恩恵が受けられるようになるんだ。例えば再利用性の観点からも、作成したマイクロサービスを全く別の用途で活用することができるかもしれないということが挙げられるね。
//}

//imagetalkr[akina_nutoral]{
全く別ですか？
//}


//imagetalkl[mai_nutoral]{
例えば社内の人事関連の管理機能をマイクロサービス化したとしよう。マイクロサービスの運用管理は人事の受け持ち人員で行われるけど、その機能を経理や総務のサービスの一部で活用することができるようになるんだ。たとえば、少し前のうちの会社の交通費関連申請は総務担当だったけど、総務は月の清算の度に人事に最新の社員名簿をもらってきて逐一エクセルファイルで照らし合わせをしなきゃいけなかったんだ。
//}

//imagetalkr[akina_ugee]{
なんですかその地獄は。
//}


//imagetalkl[mai_nutoral]{
ここしばらくで最新人事表などの一部の機能をマイクロサービス化してプログラムから取得できるようになったおかげで、照らし合わせを人手でやる必要がなくなったんだ。
//}

//imagetalkr[akina_nutoral]{
それなら一安心です。
//}


//imagetalkl[mai_nutoral]{
おととしあたりから経理も一部をマイクロサービス化して情報参照をできるようにしたんだけど、経理と人事のマイクロサービス化のおかげで総務と労働組合の支給金の確認の人手が大幅に削減できたって言ってたね。
//}

//imagetalkr[akina_nutoral]{
組合とですか。そんなこともできるんですね。
//}

//imagetalkl[mai_nutoral]{
マイクロサービスを作って形式化しちゃえばちょっとの事務処理なんてサクサクよ！
//}

//imagetalkr[akina_ooo]{
おお、言いきっちゃうのもすごいですけど確かにそれくらいのパワーはありそうですね！
//}

== セキュリティ強化

//imagetalkl[mai_nutoral]{
ここまで基礎知識からサーバーレスアーキテクチャ、マイクロサービスの設計思想などインフラにまつわる様々な知識を学んできたけど、最後の仕上げとして、セキュリティについて学んでいこうと思う。
//}

//imagetalkr[akina_ooo]{
セキュリティですか。私に理解できるか不安ですが・・・。
//}

//imagetalkl[mai_nutoral]{
基本的には「どう実現するか」というより「何をしたいか」を学ぶから、そこまでややこしいものではないよ！ひとつひとつ、ゆっくり見ていこう！
//}

//imagetalkr[akina_niko]{
よろしくお願いします！
//}

=== ポートスキャン攻撃対策

//imagetalkl[mai_nutoral]{
セキュリティの観点で一番シンプルなリスクはサーバーの解放ポートの穴をつく「ポートスキャン攻撃」だ。
//}

//imagetalkr[akina_nutoral]{
前にも出てきましたね。空いているポートを洗い出す攻撃でしたっけ。
//}

//imagetalkl[mai_niko]{
そうだね！よく覚えてるね！
//}

//imagetalkr[akina_nutoral]{
でも、空いているポートがあったとして、何が危険なんですかね？
//}


//imagetalkl[mai_nutoral]{
踏み込んで言うなら空いているポートが何かを知ることで、サーバーの用途を推察することができるね。取りえず到達したサーバーの用途を侵入者が最初から分かるわけでは無いからね。
//}

//imagetalkr[akina_nutoral]{
なるほど、下調べ的な話ですね。
//}

//imagetalkl[mai_nutoral]{
そうそう、基本的にはサービス開発者側が明示的に使用するポート以外は開けないことが前提になってるね。あとは、アプリケーションサーバーより手前の段階で接続可能なポートを指定するファイアウォールを設定することが多いね。
//}

//imagetalkr[akina_nutoral]{
なるほど、ファイアウォールってこういうものを指すんですね。よくわかってませんでした。
//}


//imagetalkl[mai_nutoral]{
ポートだけじゃなくて通信内容を調べるファイアウォールもあるから、実際の業務の前にはもっと調べた方がいいけどね。一旦は、そういうものがあるってぐらいにしておこう。
//}

=== 公開インターフェースのTSL化

//imagetalkl[mai_nutoral]{
次はTSL化についてだ。
//}

//imagetalkr[akina_nutoral]{
TSLってなんですか？
//}


//imagetalkl[mai_nutoral]{
HTTPをHTTPS化する際に参照する暗号化方式の名前だね。基本的には通信の盗聴やなりすましの防止を行う方法だ。
//}

//imagetalkr[akina_nutoral]{
盗聴とかなりすましとか、実際の詐欺みたいですね。
//}


//imagetalkl[mai_nutoral]{
それになぞらえた事件というか事例があったんだよね。まずは盗聴についてだけど、これはサーバー側とウェブブラウザ側で暗号化した通信を行ってサーバー側で復号して通信を行うね。
//}

//imagetalkr[akina_nutoral]{
どうやって暗号化するんですか？
//}

//imagetalkl[mai_nutoral]{
公開鍵認証方式っていうんだけど、まずサーバーとブラウザで同じ公開鍵を共有してそれで暗号化する。その次にサーバーに送られてきた通信をサーバーしか持たない秘密鍵で復号化して通信を行う。サーバーは公開鍵で暗号化できて秘密鍵で復号できる鍵のセットを記憶しておかなきゃいけないんだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、暗号化が公開鍵で、復号が秘密鍵ですか。それなら確かに横から暗号を読み解くことはできないかもしれません。
//}

//imagetalkl[mai_nutoral]{
いいね！いい理解だ。次になりすましについてだね。暗号化したところで通信しに行ったサーバーが何者かによって置き換えられていたとしよう。なんの気構えもしていなければ気づかずに通信してしまって重要なデータを送信してしまうかもしれない。
//}

//imagetalkr[akina_nutoral]{
そんなことがあるんですか。
//}

//imagetalkl[mai_nutoral]{
あったんだよね。それで編み出されたのが公開鍵を第三者から信頼性を証明してもらう方式だ。
//}

//imagetalkr[akina_nutoral]{
公開鍵に免許証みたいな証明書機能を持たせるんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね！免許証なら免許番号を照らし合わせれば偽造でないかが分かるよね。
//}

//imagetalkr[akina_nutoral]{
まぁ、どこで照合するのかは知らないですが恐らくそうですね。
//}

//imagetalkl[mai_nutoral]{
インターネットの世界にもその証明書が正しいものを証明する機関を置いて管理しようということになったんだ。
//}

//imagetalkr[akina_ettu]{
あれ、なんかドメイン名の話に似ているような。
//}

//imagetalkl[mai_niko]{
確かに似ているね。実際公開鍵や証明書の登録はドメイン名単位で行われることが多いからドメイン登録と近しいタイミングで証明書の発行を行うケースも多いんだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、それで証明書が発行されればなりすましされずに安全な方法で通信できるんですね。
//}

//imagetalkl[mai_nutoral]{
そうだね！TSLに関しては細かいバージョンもあるから、実際の業務の際には調べたり周りの人と相談しながら仕事を進めよう。
//}

//imagetalkr[akina_nutoral]{
わかりました。
//}


=== DDoS対策

//imagetalkl[mai_nutoral]{
さて、次はDDoS攻撃とその対策だ。
//}

//imagetalkr[akina_ettu]{
あ、DDoSってなんか聞いたことあります。沢山のコンピュータから標的に大量にアクセスするヤツですか。
//}

//imagetalkl[mai_niko]{
そうだね！素晴らしい！問題はその大量アクセスのせいでサーバーに負荷がかかりダウンしてしまうことだね。ただ、クラウドを使ってサービスを公開する場合、クラウドの機能としてDDoSを防ぐことができるオプションもあるから、しっかり調べながら使っていこう。
//}

//imagetalkr[akina_nutoral]{
クラウド側で用意されているんですか？すごいですね。
//}

//imagetalkl[mai_nutoral]{
もともと大手のウェブサイトを運用していた経験からそれらの知見を活かしてサービスとして提供しているんだろうね。まぁそれほどメジャーな攻撃なわけだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、準備をしないのは怖いですね。
//}


=== SQLインジェクション対策

//imagetalkl[mai_nutoral]{
つぎにSQLインジェクション攻撃とその対策だね。
//}

//imagetalkr[akina_ettu]{
インジェクション？なんですかこれ。
//}

//imagetalkl[mai_nutoral]{
Webサーバーとの通信時に悪意のあるSQL文をメッセージに流して、開発者の意図しないDBサーバーへの操作を行う攻撃だね。
//}

//imagetalkr[akina_ugee]{
ええ？？怖いですねそれ。
//}

//imagetalkl[mai_nutoral]{
まぁ、リクエストにSQL文を直接書くなんて方式のWebサービスを公開する人は今の時代いないだろうけどね。なにかしらプログラムのオブジェクトに置き換える方法で実装することになるはずだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、なら安心ですね。
//}

//imagetalkl[mai_nutoral]{
ただ、万が一ってこともあるから気を付ける必要があるね。あとはクラウド側でもSQLインジェクションの脆弱性がないかチェックしてくれる機能も提供されているから、そのあたりを有効活用できるといいね。
//}

//imagetalkr[akina_niko]{
また勉強するものが増えました。でも頑張ってみます！
//}

//imagetalkl[mai_niko]{
おお！がんばろう！
//}

=== 認証方式

//imagetalkl[mai_nutoral]{
ここまででサイトやサービスをどう守るかという視点でのセキュリティ対策を見てきたけど、他にもセキュリティ対策にはいろんな視点がある。その例の一つがユーザーの認証を行う方式についてだ。
//}

//imagetalkr[akina_nutoral]{
ユーザー管理というか、ユーザーログイン機能はとても基本的なことだと思ってましたが、何か特別な対策が必要なんですか？
//}

//imagetalkl[mai_nutoral]{
すごい簡単に言ってしまうと、サイトやサービスに表示される操作が可能な人とそうでない人をどう分けるかといったケースで注目されるね。自分のブログを誰かに更新されないための仕組みだ。
//}

//imagetalkr[akina_nutoral]{
あ、そうか。twitterやinstagramも自分以外が触れたら危険ですもんね。
//}

//imagetalkl[mai_nutoral]{
そうそう、そのユーザー管理の方法がひいては開発リソースへのアクセス管理という側面からも語られるようになってきている。リモートワークが浸透してきた今なら、猶更だね。
//}

//imagetalkr[akina_ooo]{
なるほど、具体的にはどんな方式があるんですか？
//}


==== ベーシック認証

//imagetalkl[mai_nutoral]{
まず最も基本的な認証方式が「ユーザーアカウント」と「パスワード」でログイン管理するベーシック認証だ。
//}

//imagetalkr[akina_nutoral]{
直訳したら基本、ですね。
//}


//imagetalkl[mai_nutoral]{
そう、基本中の基本。ユーザーの管理機能をつけたかったらまずこれを作るところから始まるね。
//}

//imagetalkr[akina_nutoral]{
どうやって作るんですか？
//}


//imagetalkl[mai_nutoral]{
パスワードを暗号化してDBにいれて、ユーザーアカウントと紐づけておくんだ。
//}

//imagetalkr[akina_nutoral]{
DBに暗号化ですか。確かに暗号化してなかったらDBの管理人が個人の情報を直接見れちゃいますもんね。
//}

//imagetalkl[mai_nutoral]{
そうだね。あとは暗号化・復号化の鍵をDBを触る人が直接触れないようにしておくのが大切だね。
//}

//imagetalkr[akina_nutoral]{
DBを触る人が鍵を触れないようにするって、アプリケーション側で鍵を持っておくってことですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。少なくともDBを触れて、かつ復号化可能な鍵を触る人が生まれないようにすることが重要だね。
//}

//imagetalkr[akina_ettu]{
そのあたりって、バグとかトラブル対応の時に大変じゃないですか？
//}

//imagetalkl[mai_nutoral]{
暗号化や復号化を全部通した状態で挙動を確認するのは開発のテストまでにおさめておきたいね。もし万が一本番運用後に必要になった場合でも、別途セキュリティ報告書とかを作って別の人が監査可能な形で操作を行えるようにするべきだね。
//}

//imagetalkr[akina_nutoral]{
厳重な管理が必要なんですね。
//}

//imagetalkl[mai_nutoral]{
万が一のことが起きたら会社の信用が吹っ飛ぶからね。こればっかりは慎重さが第一だ。
//}

==== 二段階認証

//imagetalkl[mai_nutoral]{
次は二段階認証だ。さっきのユーザーパスワードに加えてログインするごとに登録時に保存しておいた他の連絡手段に通知やワンタイムパスワードを送ってログインを再確認する方法だね。電話番号でやり取りできるSMSメッセージでのワンタイムパスワードが広く用いられてるね。
//}

//imagetalkr[akina_hee]{
よく見ますね！銀行とかクレジット明細の確認とかはよく通知が来るイメージです。
//}

//imagetalkl[mai_nutoral]{
そうだね。実際のお金周りがからむアプリは率先して導入しているね。
//}

//imagetalkr[akina_nutoral]{
やっぱり大事なものはしっかり守ってもらわなくちゃですね。
//}

==== 生体認証

//imagetalkl[mai_nutoral]{
次は生体認証だ。
//}

//imagetalkr[akina_nutoral]{
顔認証とかですね。
//}

//imagetalkl[mai_nutoral]{
そうだね。スマホの基本機能として実装されつつあるから、スマホを誰かに使われないっていう点ではとても安心できる機能だね。
//}

//imagetalkr[akina_nutoral]{
キャッシュレス決済アプリとかでよく見る気がします。
//}

//imagetalkl[mai_nutoral]{
たしかにね。やっぱりお金にかかわるものは重要だ。顔認証ならめんどくさく無いし、安全でとてもありがたいね。銀行のアプリでもPCログインは２段階認証、スマホのログインは生体認証っていう形にしてるアプリもあるね。
//}

//imagetalkr[akina_ooo]{
仕組みとしては全く違いそうですが、本人が実際に操作していることが分かればいいんですもんね。なるほどなぁ。
//}

==== OAuth2.0

//imagetalkl[mai_nutoral]{
次はOAuth2.0についてだ。
//}

//imagetalkr[akina_nutoral]{
オーオース?初めて聞きました。
//}

//imagetalkl[mai_nutoral]{
簡単に言うとtwitterやfacebookから連携アプリにログインしている時の機能だね。
//}

//imagetalkr[akina_hee]{
ああ、あれですか！
//}

//imagetalkl[mai_nutoral]{
やっぱり触ったことある？
//}

//imagetalkr[akina_nutoral]{
いちいちそれぞれのサイトでパスワードを覚えていられないので、便利でよく使っています。
//}


//imagetalkl[mai_nutoral]{
まさにその点がOAuth2.0の魅力だね！パスワード管理を個々のサービスでやるよりもセキュリティレベルの高いサービス提供者に管理を任せて、そこから貰った認証結果をもとにアプリを動かすのがOAuth2.0のざっくりとした説明だ。
//}

//imagetalkr[akina_nutoral]{
認証結果ってどんなものが貰えるんですか？
//}

//imagetalkl[mai_nutoral]{
認証トークンといってランダムに見える文字列だね。
//}

//imagetalkr[akina_nutoral]{
文字列ですか。でもそれを貰ったからと言ってどうなるんですか？
//}

//imagetalkl[mai_nutoral]{
認証トークンをアプリケーションのAPIを実行する際に常に送るんだ。操作時間が長くなったりすると認証トークンの期限が切れて、再度ログインを求められる形にするね。
//}

//imagetalkr[akina_nutoral]{
なるほど、ログインしっぱなしで誰かに使われるのを防ぐんですね。
//}

//imagetalkl[mai_nutoral]{
そうそう。まあページを読み込むたびに自動ログインを有効にしてたらあんまり意味ないけど。
//}

//imagetalkr[akina_nutoral]{
たしかに、自動ログインは便利なんですけどね。使いすぎはダメですね。
//}

//imagetalkl[mai_nutoral]{
その点、セキュリティレベルがそこまで高くなくて、利便性のみを追求したい場合はOAuth2.0、お金の操作など自分が見ているタイミングでの操作を厳重に守りたい場合は2段階認証や生体認証を使うとかユーザーの触り方を考慮したセキュリティ設定を考えることも重要だね。
//}

//imagetalkr[akina_nutoral]{
たしかに、2段階認証はめんどくさいですもんね。
//}


//imagetalkl[mai_nutoral]{
安全さと便利さのトレードオフだね。まぁでもいいところに落ち着いてると私は思うね。
//}

//imagetalkr[akina_nutoral]{
まあ確かに、お金の操作はそもそも慎重になるべきですしね。
//}

==== OpenIDConnect

//imagetalkl[mai_nutoral]{
OAuth2.0の話をしたところで確認したいのが、OAuth2.0は認証・認可のうち、認可の機能しかないって点だね。
//}

//imagetalkr[akina_ettu]{
はぇ？何言ってるんですか？ちゃんと本人確認してますよね？
//}

//imagetalkl[mai_nutoral]{
してる。より厳密にいうと、生体認証とかは本人が操作することを想定しているけど、OAuth2.0は本人が許可したアプリケーションが操作を実行することを想定しているんだ。
//}

//imagetalkr[akina_ettu]{
んん？結局本人がアプリケーションを操作しているから同じじゃないんですか？
//}

//imagetalkl[mai_nutoral]{
より分かりやすく言うと、アプリケーションに操作を委任しているとも言えるね。
//}

//imagetalkr[akina_nutoral]{
それはそうかもしれないですけど・・・でも、どうやったら認証の機能になるんですか？
//}


//imagetalkl[mai_nutoral]{
認証・認可を出す側がどのアプリケーションが実行を求めているかを管理するようになること、さらにそれぞれのアプリケーションごとに実行できる権限レベルを変えられることだ。
//}

//imagetalkr[akina_nutoral]{
あれ、OAuth2.0はそれをしてないんですか？
//}


//imagetalkl[mai_nutoral]{
OAuth2.0を使ってるアプリで認可元のアプリのどの機能を使うかっていうのは連携時に確認する決まりになってはいる。ただ、実際に実行不能の制約を書けるかどうかはOAuth2.0の規格の中には含まれていないんだ。
//}


//imagetalkr[akina_nutoral]{
そうなんですか。規格に含まれているかどうかが重要なんですね。
//}


//imagetalkl[mai_nutoral]{
規格としても厳密に定めるためには実現方法まで定義しないといけないからね。今回でいうと認証はOAuth2.0の着眼点とは少し違うということだね。そこで提唱されているのがOpenID Connectだ。これはアプリケーションやソフトの実行時ごとに認証・認可元に対して随時、認証・認可を問い直す方式だね。
//}

//imagetalkr[akina_nutoral]{
随時問い直すんですか？
//}


//imagetalkl[mai_nutoral]{
そう、毎回の認証とAPI実行毎に次の実行のための認証トークンが送られてくる。アプリケーション側は毎回そのトークンを決められた暗号鍵で暗号化して再度実行するごとに送りなおすんだ。認証・認可元はそれが正しい鍵で暗号化されていることを検証して成功すれば求められた処理を実行する。
//}

//imagetalkr[akina_nutoral]{
なんだか複雑ですね。
//}

//imagetalkl[mai_nutoral]{
そうだね。安全のためにはここまで頑張らなきゃだ。
//}

//imagetalkr[akina_nutoral]{
毎回トークンを送りなおすって言ってましたけど、操作の間が長く開いちゃったらどうするんですか？
//}

//imagetalkl[mai_nutoral]{
トークン更新用のAPIを用意しておいてそこにリクエストすることでトークンを更新していくんだ。
//}

//imagetalkr[akina_nutoral]{
その更新を誰かがなりすましたりはしないんですか？
//}

//imagetalkl[mai_nutoral]{
トークン更新用のAPIも、直前のトークンがないと実行できないようにしておくんだ。こうしておけばアプリケーションサーバーに侵入されたとしても直前のトークンはメモリ上にしか残らないから相当なことをしない限り盗聴はできないね。
//}

//imagetalkr[akina_nutoral]{
なるほど。メモリ上ですか。あれ、OAuth2.0はどうなんですか？
//}


//imagetalkl[mai_nutoral]{
認証・認可元に登録しているAPIキーとかは暗号化して環境変数に入れてたりするね。
//}

//imagetalkr[akina_nutoral]{
なるほど、暗号化しているとはいえ、サーバーに侵入されたらのぞき見られる可能性があるんですね。
//}


//imagetalkl[mai_nutoral]{
そう、その点OpenID Connectはよりセキュリティレベルが高いといえる。
//}

//imagetalkr[akina_nutoral]{
大切ですね。あれ、でもAPIを実行するのがなりすましできなさそうなのは分かったんですが、実行権限がどうのこうの言ってたのはどうなるんですか？
//}


//imagetalkl[mai_nutoral]{
アプリケーションなどのAPI実行主体がなりすまし不可能になることで、管理側もどのアプリケーションが実行を求めているかが分かるようになる。これで初めて管理側もどのアプリケーションにどれほどの強さの権限を付与するかを管理することができるようになるんだ。
//}

//imagetalkr[akina_nutoral]{
なるほど！なりすましができないことが重要なんですね！少しわかった気がします。
//}

//imagetalkl[mai_niko]{
いいね！これがOpenID Connectの特徴だ。必要なタイミングで実装できるように覚えておこう！
//}

//imagetalkr[akina_niko]{
わかりました！
//}


