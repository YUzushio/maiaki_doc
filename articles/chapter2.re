
= 良いプログラムの作り方

//imagetalkl[mai_nutoral]{
さてさて、ここまでウォーターフォール、アジャイルときてXPの説明をしたんだけど、あきなちゃんに聞きいておきたいことがあるんだ。
//}

//imagetalkr[akina_nutoral]{
はい、なんでしょう？
//}

//imagetalkl[mai_niko]{
良いプログラムとはなにか？
//}

//imagetalkr[akina_eee]{
はぇ！？
//}

//imagetalkl[mai_ahaha]{
何かない？なんでもいいよ？
//}

//imagetalkr[akina_ettu]{
えぇ～と、読みやすい？
//}

//imagetalkl[mai_niko]{
そうだね！大切だ。他には?
//}

//imagetalkr[akina_komari]{
改変しやすい
//}

//imagetalkl[mai_dahaha]{
うんうん！大事だね！他には？
//}

//imagetalkr[akina_komari]{
軽い？
//}

//imagetalkl[mai_niko]{
重くて動かなかったら最悪だもんね！他には？
//}

//imagetalkr[akina_ugee]{
う～ん、思い浮かばないです。
//}

//imagetalkl[mai_niko]{
OK、じゃ私が考えていることを教えよう。それは
保守性の高さ
省力性の高さ
信頼性の高さ
移植性の高さ
だ。保守性とは読みやすさや書きやすさ、省力性は軽かったり早かったりすることだね。
//}

//imagetalkr[akina_ettu]{
信頼性って、どうやって計るんですか？
//}

//imagetalkl[mai_nutoral]{
テストの数と質。これでどんな動きがあって、どういう使い方をしたらどういう結果が出るかを保証する。保証範囲が広く、入り組んだケースであっても保証が行き届いていることが重要だね。
//}

//imagetalkr[akina_ooo]{
なるほど、移植性ってなんですか？
//}

//imagetalkl[mai_nutoral]{
移植性は他のプロジェクトなどにコードを移植しやすいかどうかの評価だね。依存しているライブラリが特定のネットワークでしか手に入らない場合なんかは移植性が低いと言わざるを得ないね。
//}

//imagetalkr[akina_ooo]{
なるほど、再利用ってことですか。
//}

//imagetalkl[mai_nutoral]{
そう。だけどそれ以外にも問題を再現をしたいといったときにもこの移植性がネックになることもあるよね。
//}

//imagetalkr[akina_hee]{
同期の子が「問題再現できる環境がない！！」って困っていましたけど、そういうことなんですね。
//}

//imagetalkl[mai_niko]{
そうそう。いろいろ困ることが多いからね。作る時に意識しなきゃいけないんだよねぇ。じゃあ、いまから保守性、省力性、信頼性、移植性について見ていこう！
//}

== 保守性の高いプログラム

//imagetalkr[akina_ettu]{
そもそもなんですけど、読みやすいプログラムってどういうものを指すんですか？言語を詳しく知らないと読みづらいのか自分の知識が足りないのかわからないと思うんですけど。
//}

//imagetalkl[mai_niko]{
いい着眼点だね。じゃあ読みやすく書きやすいプログラムとは何か、いくつかの項目に分けて考えていこう
//}

=== 読みやすく書きやすいプログラム

//imagetalkl[mai_nutoral]{
まず最初にコードの読みやすさと言語仕様によるコードの特殊な書き方は分けて考えよう。
//}

//imagetalkr[akina_ettu]{
分けると言うと？
//}

//imagetalkl[mai_nutoral]{
そもそもコードは各言語仕様によってクラスの書き方や変数の定義の仕方が違う。もちろんそれは特殊なほど読みづらいと感じるし普遍的なほど読みやすいと感じる。だけど言語ごとに違う特徴はその言語がどういうケースで用いられるかということまで遡る必要があるので言語仕様の違いによる読みにくさ読みやすさというものは一旦は自分の中で飲み込むことにしよう。
//}

//imagetalkr[akina_ooo]{
なるほど。 じゃあどんなものを読みやすいプログラムとするんですか？
//}

==== わかりやすく、短く、無駄がない

//imagetalkl[mai_nutoral]{
大原則として考えられるのが「わかりやすい」「短い」「無駄がない」の三拍子がそろったコードだ。
//}

//imagetalkr[akina_nutoral]{
「わかりやすい」は「読みやすい」と違うんですか？言葉遊びでズルしてる気がします・・
//}

//imagetalkl[mai_nutoral]{
その気持ちはよくわかる。もう少し踏み込んで言うと「目的と手段が明確に結びつけやすい」っていうのが正しいかもね。
//}

//imagetalkr[akina_nutoral]{
なるほど、それなら納得です。
//}

//imagetalkl[mai_nutoral]{
それでもって、短くて、無駄がないコードを目指すべきってことだね。
//}

//imagetalkr[akina_nutoral]{
その二つも同じ意味なんじゃないですか?
//}

//imagetalkl[mai_nutoral]{
うー－ん、一番ピンとくるのは一通りのやりくりは短いけど、そのせいで逆に無駄な変数が多い場合かな。
//}

//imagetalkr[akina_nutoral]{
そんなことがあるんですか？
//}

//imagetalkl[mai_nutoral]{
まぁいつかあきなちゃんも出会うよ。見た目の短さのためだけに遠回りなことしてるコードに。
//}

//imagetalkr[akina_nutoral]{
気を付けます。でも、そういう時はどうしたらいいんですか？
//}

//imagetalkl[mai_nutoral]{
まず、読む側のわかりやすさを優先する。その次に原則は短さを優先するけどそれが「無駄のなさ」と衝突する場合は「無駄のなさ」を優先しよう。
//}

//imagetalkr[akina_nutoral]{
なるほど、わかりました。わかりやすさが一番なんですね。
//}

//imagetalkl[mai_nutoral]{
うん、そうしよう。あと、「無駄のなさ」については一旦「同じコードを複数個所に書かない」と考えよう。
//}

//imagetalkr[akina_ettu]{
それだけですか?
//}

//imagetalkl[mai_nutoral]{
「無駄のなさ」にはいろんな観点があるから、今はそれだけ覚えてもらえるといいと思う。後々、沢山出てくるよ。まぁそれは一旦置いといて、「わかりやすさ」が最優先だ。そしてそのためにはコードコメントを残すことを習慣化しよう。
//}

==== コードコメント

//imagetalkr[akina_ettu]{
コードコメントですか？
//}

//imagetalkl[mai_nutoral]{
うん、そう。プログラム本体には影響しないけどコードの文面に残るメッセージのことだね。
//}

//imagetalkr[akina_hee]{
あーなんかシャープとかスラッシュが二つとかついてるやつですね
//}

//imagetalkl[mai_niko]{
そうそう！それをどんどん書いていこうっていう話だ。
//}

//imagetalkr[akina_komari]{
なんかめんどくさそうなんですけど。
//}

//imagetalkl[mai_tohoho]{
そうだね面倒くさいね。でもこれが案外重要なんだよね。
//}

//imagetalkr[akina_ettu]{
そのコードコメントは英語で書いたほうがいいんですか？プログラムは英語ですし。
//}

//imagetalkl[mai_nutoral]{
プロジェクトに英語話者がいる場合は英語がいいね。そうでなければ日本語で書こう。
//}

//imagetalkr[akina_ooo]{
なんかかっこ悪い気がしますけど日本語なんですね。
//}

//imagetalkl[mai_nutoral]{
うん、そう。私の過去のプロジェクトでは翻訳をかけた英語を貼ったコメントが結局英語話者にも日本人にも伝わらなくて何をやってるかわからないっていうことがあったからね。
//}

//imagetalkr[akina_ugee]{
うわーそれ地獄ですね。
//}

//imagetalkl[mai_tohoho]{
大変だったんだから。だから絶対日本語、日本人だけのチームならね。
//}

//imagetalkr[akina_nutoral]{
わかりました。コードコメントに関しては分かったんですけどプログラム本体には何かないんですか？
//}

==== キャメル、スネーク、ケバブ

//imagetalkl[mai_nutoral]{
最も普遍的なルールは命名規則だね。
//}

//imagetalkr[akina_nutoral]{
もしかして、大文字とかアンダーバーの話ですか。
//}

//imagetalkl[mai_niko]{
そうそう。変数や関数の名前をつける時に「SampleObject」のように単語の先頭を大文字にして書くことをキャメルケース、「sample_object」のように単語と単語の間をアンダーバーで区切るのスネークケース、「sample-object」のように単語と単語の間をハイフンで区切るのをケバブケースっていうんだ。
//}

//imagetalkr[akina_ettu]{
ケバブケースというのは初めて聞きました
//}

//imagetalkl[mai_nutoral]{
串焼きに似てるからっていう理由でケバブって言うらしいね.
//}

//imagetalkr[akina_nutoral]{
ケバブってお祭りで見たことある気がします。長い串にお肉が何層も積まれてるやつ。
//}

//imagetalkl[mai_ahaha]{
そうそうああいう感じのやつ！まあそれだけじゃなくて日本の串焼きとかの方が近いんだけどね。
//}

//imagetalkr[akina_nutoral]{
私、仕事とかでケバブケースっていうのはあんまり見てないです。
//}

//imagetalkl[mai_nutoral]{
まあ私も見ないし日本の現場では珍しいんじゃないかな。
//}

//imagetalkr[akina_ettu]{
ちなみにですけどまいさんはキャメルケースとスネークケースどっちが好きですか？
//}

//imagetalkl[mai_nutoral]{
私はキャメルケースだね。なんでかって言うと今使ってるフレームワークがキャメルケースだからかな。
//}

//imagetalkr[akina_ooo]{
もしかしてプロジェクトごとに好みが変わったりしますか？
//}

//imagetalkl[mai_nutoral]{
触る言語やフレームワークがどちらかに偏ってると数年単位で推しが変わることはあるね。
//}

//imagetalkr[akina_ooo]{
推し・・・ですか。
//}

//imagetalkl[mai_niko]{
そう推し。結局統一されてればどっちでもいい気もするしね。
//}

//imagetalkr[akina_nutoral]{
混ざってなければいいということでいいですか？
//}

//imagetalkl[mai_niko]{
一旦はそれでいいと思うよ。プロジェクトのルールに従ってプロジェクト内で統一していこう。
//}

//imagetalkr[akina_niko]{
わかりました。
//}

==== 英語、ローマ字、日本語

//imagetalkl[mai_nutoral]{
あきなちゃんはこんな変数名見たことあるかな?「ShukuhakuKakuteiShisetsu」
//}

//imagetalkr[akina_ugee]{
うぇ、、ないです。なんですかこれ、宿泊確定施設?旅行予約のデータか何かですか？
//}

//imagetalkl[mai_nutoral]{
そうそう、予約プランの中ですでに宿泊が確定している施設のみを表したい時に作られた変数。私が実際プロジェクトで見た現物だ。
//}

//imagetalkr[akina_eee]{
ネーミングセンスがひどくないですか？
//}

//imagetalkl[mai_niko]{
そう思うよね。じゃあ今回はこれをどういう名前にすればいいかを考えていこう。 
//}

//imagetalkr[akina_nutoral]{
英語にしちゃえばいいんじゃないですか？ReservedFacilitiesとか
//}

//imagetalkl[mai_ahaha]{
お、いいね。じゃあ予約データの中には宿泊ではないけど利用が確定している施設があるとしよう。どちらも使い分けたい場合、さっきの名前でいいかな?
//}

//imagetalkr[akina_komari]{
うー－んと、宿泊はStayかな・・・
//}

//imagetalkl[mai_nutoral]{
ネットで調べると「Lodging」って出てくるね
//}

//imagetalkr[akina_nutoral]{
じゃあ「LodgingReservedFacilities」かな、いや長いな。気持ち悪いです。いや、そもそも「Facilities」が要らないから「ReservedLogging」か。
//}

//imagetalkl[mai_nutoral]{
じゃあさらに追加で宿泊施設内の特殊施設の利用情報の定義も必要になったとしよう。ジムとかプールとかのイメージだね。
//}

//imagetalkr[akina_komari]{
「LodgingReservedFacilitesSpeciality」とかですか？うう嫌だ。せめて「LodgingReserved」と「FacilitySpeciality」を別テーブルとかオブジェクトにしたい・・・
//}

//imagetalkl[mai_nutoral]{
さらにここで「予約が確定しているわけではないけど予約プランに入れいている施設」を一次的に保存する必要があるって要望が来た。どうする？
//}

//imagetalkr[akina_eee]{
え？予約の英語は・・・Reservedってうわー－！確定と予約でかぶるー－！
//}

//imagetalkl[mai_dahaha]{
あっはは！やっぱそうなるよね！みんな同じことになるね！
//}

//imagetalkr[akina_doshite]{
いやこの流れ確定だったんですか。ひどくないですか？
//}

//imagetalkl[mai_niko]{
いやいや、話で聞くより自分で味わった方がわかりやすいかと。
//}

//imagetalkr[akina_ettu]{
それはそうですけど・・・・
//}

//imagetalkl[mai_nutoral]{
日本語の予約と、確定ってニュアンスを英語で表現するのって難しいよね？
//}

//imagetalkr[akina_nutoral]{
英語が喋れたなら別ですけど、今の私では難しいです。
//}

//imagetalkl[mai_nutoral]{
日本人で英語ネイティブレベルなんてそうそうないからね。逆にネイティブ同士で伝わっても私たちにつたわらなかったら意味ないよね。
//}

//imagetalkr[akina_komari]{
そうですね。でも「ShukuhakuKakuteiShisetsu」は嫌だー。長いー。
//}

//imagetalkl[mai_dahaha]{
あっはっは！私も嫌だねぇ。ちなみに変数名を日本語にすることもできるよ。
//}

//imagetalkr[akina_ettu]{
へ！？そうなんですか？
//}

//imagetalkl[mai_niko]{
うん。結構多くの言語でサポートしてるね。英単語がプログラミングが英語話者にとってナチュラルなことを考えたら、我々もナチュラルな言語で変数を考えてもいいかもしれない。
//}

//imagetalkr[akina_ooo]{
なるほど・・・日本語、コード内で使えるんですね。私は見たことありませんが、まいさんはありますか？
//}

//imagetalkl[mai_ahaha]{
あるよ！みんなウキウキで実装してたけどある日突然問題が発覚してね。データベース接続を担うコードで大事件が起きたんだ。
//}

//imagetalkr[akina_ettu]{
データベースで？
//}

//imagetalkl[mai_uun]{
そう、使用していたデータベースではプログラムのオブジェクトに対応するはずのテーブル名に日本語が使えなかったんだ。
//}

//imagetalkr[akina_eee]{
ひぇー－！
//}

==== プロジェクトワード集

//imagetalkl[mai_nutoral]{
ということもあり、その後の旅行関係のプロジェクトで出てきた案がこれ「ShukhkKaktiShists」
//}

//imagetalkr[akina_ettu]{
え？なんですかこれ、Shukuhakuの二個目以降の母音を抜いたやつ?「確定」も「施設」も二個目以降の母音が抜けてる。
//}

//imagetalkl[mai_nutoral]{
そうそう、ほかに出てこなさそうな子音の並びと一個目の母音だけ残して略称を使う方法だね。
//}

//imagetalkr[akina_eee]{
確かに短くはなりましたけど、これじゃ初めて見た人はわからないですよ。
//}

//imagetalkl[mai_nutoral]{
そうだよね。ってことで私のプロジェクトでは、略称ローマ字表記を用いつつプロジェクト着任時の初回研修で必ずこの略称を含めたプロジェクトワード集を読ませることにした。オンラインでチーム全体が見える形でね。
//}

//imagetalkr[akina_ooo]{
まぁ・・・前もって説明があるならまだ・・・
//}

//imagetalkl[mai_tohoho]{
ちなみに同じ略称使ってるけどプロジェクトワード集を作ってない話はたくさん聞く。
//}

//imagetalkr[akina_eee]{
それは嫌だー！
//}

//imagetalkl[mai_uun]{
ワード集を作っててもビジネスパートナーのメンバーには見れない場所に保管してるチームもある。
//}

//imagetalkr[akina_ugee]{
もうやめて！プログラマーのライフはゼロです！！！
//}

//imagetalkl[mai_dahaha]{
あっはっは！ひどい話だよねぇ！！まぁ、そんな過去の地獄は置いといて、結局はメンバーがわかりやすく、なるべく短い名前付けがいいよね。
//}

//imagetalkr[akina_nutoral]{
わかりやすくするためのワード集を作るのはアリと
//}

//imagetalkl[mai_niko]{
そうそう！むしろ略称が必要ないとしてもお客さんごとに専門分野の単語とか概念とかあるからワード集は必須だよね！
//}

//imagetalkr[akina_nutoral]{
必須ですね。
//}

//imagetalkl[mai_niko]{
もし参加したプロジェクトになかったらあきなちゃんが作ってあげてね。
//}

//imagetalkr[akina_eee]{
えええ！？はじめて入った分野なんて全然わかんないですよ！？
//}

//imagetalkl[mai_nutoral]{
お客さんに一つ一つ聞きながら作るのだ。そしてそれは必ず自分の糧になる。
//}

//imagetalkr[akina_ugee]{
頑張り損な気がします・・・
//}

//imagetalkl[mai_niko]{
その分のちの残業が減ると思えば！
//}

//imagetalkr[akina_iyaa]{
うう・・善処します。
//}

===[mycolumn]おススメ書籍

リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック

//image[readablecode][][scale=1]

出版社  : オライリージャパン; 初版八刷 (2012/6/23)

発売日  :  2012/6/23

ISBN-10  :  4873115655

ISBN-13  :  978-4873115658

おすすめポイント：読みやすく書きやすいプログラムを書くことを目指すプログラマにとってのバイブル。自らのコーディングに疑問を持った際に真っ先に確認すべき数々の視点が書かれている。何度も読み返すことでそのたびごとに新たな視点に気づける点でも手元に置く価値のある一冊。



===[/mycolumn]

=== 変更しやすいプログラム

//imagetalkl[mai_nutoral]{
では次、変更しやすいプログラムについてだ。
//}

//imagetalkr[akina_nutoral]{
読みやすさ、書きやすさとは違うんですよね？
//}

//imagetalkl[mai_nutoral]{
うん。むしろその二つを前提にしたプログラムだね。最も代表的な例でいうと

1. 変数の定数化
2. 関数定義の抽象化
3. クラス定義の抽象化

の3つだ。
//}


==== 変数の定数化

//imagetalkr[akina_nutoral]{
変数の定数化ってなんですか？java でいうconstとかfinal句を使えってことですか？
//}

//imagetalkl[mai_nutoral]{
部分的にそうだね。まぁ詳しく言うと

プログラム内で同値で頻出する変数は定数に定義する
複数プログラム間で同値で頻出する変数は参照可能な外部定数にする

の二つを考えよう。
//}


//imagetalkr[akina_nutoral]{
	「プログラム内で同値で頻出する変数は定数に定義する」は納得です。私も一年間よく指摘されましたし自分でもできるようになってきていると思います。
//}

//imagetalkl[mai_niko]{
いいね、複数プログラムの方はどうだろう。Javaだと列挙型っていう形にされるのが多いね。
//}

//imagetalkr[akina_ooo]{
列挙型ならわかります。なるほど、複数プログラム間で定数を扱うための物だったんですか。
//}

//imagetalkl[mai_nutoral]{
それだけではないけどとても大きな役目だね。で、定数化をすることで中身の変数がプロジェクト全体で変える方針になった場合も変更箇所がとても少なくて済む。むしろ複数個所を直す余裕なんてプロジェクトにはそもそもない。もっと致命的な問題を解決させるために予備時間は使われるべきだ。
//}

//imagetalkr[akina_nutoral]{
でも、みんなが使う定数の場所っていろんなものが置かれちゃったりしないですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。そこで定数管理をする人を決めて、プロジェクトワード集と照らし合わせながらプロジェクト全体に影響する定数を決定・周知させていく。
//}

//imagetalkr[akina_nutoral]{
なるほど。管理人がいたら相談しやすいですね。
//}

//imagetalkl[mai_nutoral]{
負担が集中するから当番制でもいいかもね。
//}

//imagetalkr[akina_nutoral]{
たしかに。機会があったら提案してみます。
//}


==== 関数定義の抽象化

//imagetalkl[mai_nutoral]{
変更しやすいプログラムを作る方法の2つ目が関数定義の抽象化だ。
//}

//imagetalkr[akina_nutoral]{
抽象化・・・ですか。うまくイメージできません。
//}

//imagetalkl[mai_nutoral]{
簡単に言うと、使い勝手を良くするってことだね。
//}

//imagetalkr[akina_nutoral]{
うー－ん、それってプログラマは常に考えていることなんじゃないですか？
//}

//imagetalkl[mai_niko]{
そうだね。じゃもう一歩踏み込んで説明すると。「いくつかのパターンの入力の組み合わせでも動作するものを作る」だね。
//}

//imagetalkr[akina_nutoral]{
なるほど、それが「使い勝手の良さ」ですか。
//}

//imagetalkl[mai_nutoral]{
そう、いくつかの変数を入力として使用するけど状況によっては一部の変数が用意できないことがある。それでも「機能としては同じものを使いたい」という場合にこの設計をしているかどうかで使い勝手が大きく違う。下手をすると同じ機能を達成するのにいくつも似たようなコードの関数が乱立するなんてことになっちゃう。
//}

//imagetalkr[akina_ooo]{
そういうコード、読んだら混乱しそうです。
//}

//imagetalkl[mai_uun]{
さらに計算ロジックを変えてくれって言われて修正することになったら地獄だよね。
//}

//imagetalkr[akina_ugee]{
地獄です。
//}


//imagetalkl[mai_nutoral]{
しかも一部は名前と入力変数がが似てるだけで別の用途に使ってる関数でした、なんてこともある。
//}

//imagetalkr[akina_komari]{
もう直さずに新しい関数つくっちゃいたくなります
//}

//imagetalkl[mai_nutoral]{
だよね。まぁそんなことにならないために。同じ用途であれば複数の入力変数のパターンに対応できる書き方をするべきだ。
//}

//imagetalkr[akina_niko]{
納得です！
//}

//imagetalkl[mai_uun]{
まぁ、Javaはほかの言語に比べてこの書き方はめんどくさいんだけどね。
//}

//imagetalkr[akina_eee]{
えぇ!?うそぉ！
//}

//imagetalkl[mai_niko]{
ちょっとだけ、だけどね。
//}

//imagetalkr[akina_nutoral]{
むしろほかの言語は簡単なんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。PythonもJavaScriptも関数の引数にデフォルト値を設定できて、デフォルト値が設定されている関数であれば少ない引数分は自動で補完して関数実行してくれるよ。
//}

//imagetalkr[akina_nutoral]{
便利そうですね。
//}

//imagetalkl[mai_nutoral]{
まぁJavaScriptは型を意識しない書き方ができる反面、コードの解読が難しくなりがちなんだけど。
//}

//imagetalkr[akina_nutoral]{
長所短所があるんですか。
//}

//imagetalkl[mai_nutoral]{
そうだね、JavaScriptはとくに。JavaScripptに型を意識させた形のTypeScriptなら負の影響は少ないけどね！
//}

//imagetalkr[akina_nutoral]{
なるほど、TypeScript・・・勉強してみます！
//}


==== クラス定義の抽象化

//imagetalkl[mai_niko]{
OK!次は「クラス定義の抽象化」だ。
//}

//imagetalkr[akina_ooo]{
これも関数定義の抽象化と同じなんですか？
//}

//imagetalkl[mai_nutoral]{
これもまた部分的にそう、って感じだね。４割くらいかな。
//}

//imagetalkr[akina_ettu]{
あと6割もあるんですか。
//}

//imagetalkl[mai_nutoral]{
うん、じゃあ見ていこう。まずはさっきの関数の抽象化に近いけど、クラスのコンストラクタの入力の種類が異なるパターンについてだ。これもJavaならオーバーロード、PythonやJavaScriptならデフォルト値が使えるね。
//}

//imagetalkr[akina_nutoral]{
クラスインスタンスの生成の引数にパターンがあることがあるんですか？
//}

//imagetalkl[mai_nutoral]{
例えばWebサイトのGUIとかを考えてみよう。ECサイトがいいかな。お店側が新しい商品の投稿をしたいときに、最初から割引設定を作ることもできるし、後から割引設定を追加できるようにしたい。そうなった場合に商品投稿データのコンストラクタ引数に割引設定が必須な設計をしていたら、割引設定なしの登録ができなくなってしまうかもしれないよね。
//}

//imagetalkr[akina_nutoral]{
んーそれは割引設定を空文字列にして渡すことで解決できる気がしますが
//}

//imagetalkl[mai_nutoral]{
割引設定が条件や割引値などの細かいパラメータを持つ独自のクラスならどうだろう。
//}

//imagetalkr[akina_ugee]{
うっ・・・それは・・・たしかにコンストラクタに何かしら指定された情報があってほしいですね。
//}


//imagetalkl[mai_nutoral]{
そうだよね。割引設定のクラスの型でありながらデフォルト値はnull、入力される場合はそのクラスを入れる。もしくはその引数の無い形のコンストラクタをつくる。その方がきれいだよね。
//}

//imagetalkr[akina_hee]{
はい。そっちの方がいいと思います。
//}


//imagetalkl[mai_niko]{
OK、そんなこんなでコンストラクタに関する抽象化の話をしたわけだけど、コンストラクタ以外にも抽象化すべきものが沢山ある。
//}

//imagetalkr[akina_nutoral]{
複数の関数があってこそのクラスですもんね。
//}

//imagetalkl[mai_nutoral]{
そうそう。じゃあさっきの割引設定の話をもってこよう。一日に一回、商品の割引設定を参照して、割引期間が過ぎたものを商品の割引設定から削除したい。どうやって実装しようか。
//}

//imagetalkr[akina_nutoral]{
商品クラスに割引設定を削除する関数を作ります。その関数は多分ECサイトのサーバー側が日時指定で各クラスごとに実行することになると思います。あれ、でもそれサーバーの負荷が大変なことに・・・
//}

//imagetalkl[mai_niko]{
OK、一旦サーバー負荷や実現可能性の話は置いておこう。クラス定義の抽象化に集中したいからね。ここで追加の質問。実はさっきまで言っていた商品は実はサブスクリプション商品と買い切り商品が別々のクラスになっていた事実を知らされたとしよう。さっきまで触っていたのは買い切り商品専用のクラスだった。
//}

//imagetalkr[akina_eee]{
ええ？後出しでずるいですよ。でも、別のクラスならそれぞれのクラスに同じ関数を作って・・・いや気持ち悪いですね。同じコードが複数にあるの。
//}


//imagetalkl[mai_nutoral]{
そうだよね。こういう場面で使われるのが抽象クラスだ。
//}

//imagetalkr[akina_ooo]{
あ、なんか聞いたことがあります。
//}

//imagetalkl[mai_niko]{
いいね。今のでいえば改めて商品というような抽象クラスを作り、そこに割引設定削除を含めた共通の処理を書いておくんだ。そうすれば一か所でコードを管理できて変更の手間もない。
//}

//imagetalkr[akina_nutoral]{
なるほど。大切ですね。
//}

//imagetalkl[mai_nutoral]{
じゃあもう一歩踏み込もう。今のはお店側の視点でデータを考えたけど当然お客さんもそのサイトを見るわけだ。
//}

//imagetalkr[akina_nutoral]{
はい。
//}

//imagetalkl[mai_nutoral]{
商品を登録したんだからお客さんからも商品データが見えて当然だよね。
//}

//imagetalkr[akina_nutoral]{
そうです。
//}

//imagetalkl[mai_nutoral]{
決済確認ページでも商品は見えたほうが安心するよね。
//}

//imagetalkr[akina_nutoral]{
はい。そっちの方がいいです。
//}


//imagetalkl[mai_nutoral]{
でもここでプログラマーにとって問題が起きた。決済対象の商品を扱うクラスと普段の商品を提示する時のクラスに共通な処理がほとんどない。むしろ変数の数も違うしほとんど別物が必要になってしまった。でも、決済画面で商品名や画像、出店者も確認したい。こんな時にどうするか。
//}

//imagetalkr[akina_ettu]{
それはもう別のクラスでそれぞれ書けばいいんじゃないですか？
//}

//imagetalkl[mai_nutoral]{
そういう場面でも抽象化の概念は力を発揮する。オブジェクト指向の概念の一つ、インターフェースを作るんだ。
//}

//imagetalkr[akina_ettu]{
インターフェース？表面というか、窓口みたいな形ですかね？
//}

//imagetalkl[mai_nutoral]{
言いえて妙だね。まさに表面だけをなぞる様に共通処理の呼び出し口だけを作り、中身はそれぞれのクラスに任せる。それがインターフェースだ。
//}

//imagetalkr[akina_komari]{
必要なんですか？そんなの
//}

//imagetalkl[mai_niko]{
便利なんだよ。インタフェースを実装するクラスは必ずインターフェースに定義された関数の入力と出力の型に合わせた関数を持っていなければならない。そしてインターフェースを使う側はその内部動作を気にせず意図した結果の型を取得できるんだ。中身がどんなクラスかを気にせずにね。
//}

//imagetalkr[akina_nutoral]{
んーなるほど、決済画面商品データも普段の商品表示データも同じインターフェースを持っていれば商品名や画像など簡単なデータを持ってくることができるんですね。
//}

//imagetalkl[mai_niko]{
そうそう！それでいてデータ構造的には全く違う代物でもいいんだ。安心してコーディングができる。さらにいえばプログラマ同士が分業してコードを書く際に入力と出力の取り決めさえしていればお互いのコードを待たずに作業を並行できることもある。結構便利な概念なんだ。
//}

//imagetalkr[akina_nutoral]{
納得です。使ってみたくなりました。
//}

//imagetalkl[mai_ahaha]{
いいね。プログラムの抽象化に関してはほかにもいろなパターンが考案されていて、「デザインパターン」や「オブジェクト指向プログラミング」について調べてみるのもいいと思うよ！
//}

//imagetalkr[akina_niko]{
ありがとうございます。調べてみます！
//}


=== 新たなバグを発生させにくいプログラム

//imagetalkl[mai_niko]{
次は「新たなバグを発生させにくいプログラム」だ。
//}

//imagetalkr[akina_nutoral]{
新たなバグを発生させないって、そんなプログラム作れるんですか？
//}

//imagetalkl[mai_nutoral]{
あくまで「発生させにくい」だからね。バグはあるよ。いつか出会う。それでもくだらないバグを産ませないためにできることをする、そういう考えだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、ではどうするんですか？
//}

//imagetalkl[mai_nutoral]{
テストを作る。
//}

//imagetalkr[akina_ettu]{
それだけですか！？
//}

//imagetalkl[mai_nutoral]{
テストを作り続ける。
//}

//imagetalkr[akina_eee]{
終わらない戦いじゃないですか？
//}

//imagetalkl[mai_uun]{
そもそもモノづくりなんて終わらない戦いだよ。
//}

//imagetalkr[akina_komari]{
いや、そんな禅問答みたいに言われても・・・
//}

//imagetalkl[mai_nutoral]{
まぁ、そのプロジェクトの納期と見比べて「今回はこの辺で手打ちにしてやろう」っていうのがテスト計画な部分もある。
//}

//imagetalkr[akina_nutoral]{
戦いと言い今度は武将ですか
//}

//imagetalkl[mai_niko]{
引き際を見極めるのが大切です。
//}

//imagetalkr[akina_nutoral]{
お後がよろしいようで。
//}

//imagetalkl[mai_oko]{
おい！ツッコミを放棄するな！
//}

//imagetalkr[akina_iyasono]{
いや何させたいんですか。本当に。
//}

//imagetalkl[mai_ahaha]{
やーごめんごめん調子のっちゃった。で、バグを少なくするためにはテストが必要で、テストはやれるだけやった方がいいけどプロジェクトのリソースは余ってはいないので、ある程度のレベルでテストを切り上げてその品質を含めお客さんに納得してもらうのが普段我々のやっていることだ。これに関しては認識合ってるかな？
//}

//imagetalkr[akina_nutoral]{
はい。私もそう思います。
//}

//imagetalkl[mai_nutoral]{
そこでもうひとつ、「新しいバグを発生させにくい」という観点で必要なことがある。
//}

//imagetalkr[akina_ettu]{
もう一つあるんですか。なんでしょう？
//}

==== テスト自動化

//imagetalkl[mai_nutoral]{
テストの自動化だ。
//}

//imagetalkr[akina_nutoral]{
自動化ですか。ファイルを保存したら勝手にテストが動く、とかですか？
//}

//imagetalkl[mai_niko]{
そうだね。それに加えてコード管理システムで誰かから変更が加えられた際にテストを自動で実行させて、エラーが発生したら加えられた変更を強制的に巻き戻すこともできる。
//}

//imagetalkr[akina_ooo]{
エラーがあるコードは強制排除ですか。すごいですね。たしかに新たなバグは発生しにくそう。
//}

//imagetalkl[mai_nutoral]{
もちろん実行コードが追加された分だけテストコードも追加されるって前提じゃないと意味ないけどね。
//}

//imagetalkr[akina_ettu]{
んん？それって意味がなくなるほどなんですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。Aさんがもし実行コードだけ作ってテストを作らなかったとする。潜在リスクは潜在したままだからもちろんテストは失敗にならないね。でもそのあとにBさんが同じようなところを追加で変更したとしよう。Bさんの時になってリスクが顕在化すると、Bさん自身は間違ったコーディングをしていないのにAさんが発生させたバグ・エラーのせいで作ったものがいつまでたってもコード管理システムに受容されない、なんてことがおこるんだ。
//}

//imagetalkr[akina_ugee]{
Bさんかわいそうすぎる。
//}

//imagetalkl[mai_nutoral]{
万が一、Aさんがすでにプロジェクトを離任していたとしたら終わりの見えないデスマーチが始まることになるね。
//}

//imagetalkr[akina_eee]{
ひぃ～～！
//}

//imagetalkl[mai_nutoral]{
まぁ、テストの自動化についてはまた後で出てくるから今はこのあたりにしとこう。次はコードレビューだ。
//}

==== コードレビュー

//imagetalkr[akina_nutoral]{
コードレビューですか。それくらいならできそうですね。
//}

//imagetalkl[mai_niko]{
いいね。前のプロジェクトでもやってたんだ？
//}

//imagetalkr[akina_nutoral]{
はい。コードを本番に移行する前に先輩とリーダーに見てもらいました。
//}

//imagetalkl[mai_ahaha]{
すばらしい。いいプロジェクトだね！
//}

//imagetalkr[akina_ettu]{
そんなに注目するものなんですか？てっきりどこでもやっているかと思ってました。
//}

//imagetalkl[mai_uun]{
実は、すべての現場でコードレビューが確実に行われているわけではないね。うちの会社は大丈夫だけど、実装をビジネスパートナーに任せっきりな会社が日本には結構ある。
//}

//imagetalkr[akina_nutoral]{
そうなんですか。
//}

//imagetalkl[mai_nutoral]{
海外にコーディングをアウトソーシングしてる場合とかもあるね。一番怖いのはプロジェクト管理者がコーディング経験が浅くてプロダクト管理者としてのレビューをできなていない場合があるんだ。
//}

//imagetalkr[akina_ugee]{
そーれ地獄です。どれだけの種類の地獄があるんですかね。この業界。怖すぎます。
//}

//imagetalkl[mai_ahaha]{
数えてたら気が狂っちゃうね。上を向いて歩こう。
//}

//imagetalkr[akina_ugee]{
足踏み外しませんか？上ばかり見てたら。
//}

//imagetalkl[mai_dahaha]{
あっはは！それもそうだね。バランスよく、朗らかに行こう。
//}

== 省力性の高いプログラム

//imagetalkl[mai_nutoral]{
次は省力性の高いプログラムだね。あきなちゃんも最初にピンと来ていたように、軽さや速さが良いプログラムの指標だ。
//}

//imagetalkr[akina_nutoral]{
研修でも言われていたのと、ドラマとかアニメでも凄腕ハッカーとかが速さがどうとか言ってるイメージがあります。
//}

=== 計算リソースを浪費しないプログラム

//imagetalkl[mai_niko]{
そうだね。だいぶ誇張されてるけど、確かに速さと軽さは現場でも気にすることが結構あるね。ただ、現在のプログラㇺの実行環境ではかつて言われていたほどプログラムの軽さを気にすることは無くなってきている。
//}

//imagetalkr[akina_nutoral]{
そうなんですか？
//}

//imagetalkl[mai_nutoral]{
単純に、マシン性能が昔とは大違いだからね。昔のファミコンと今のPCじゃ、差がありすぎる。プログラムサイズを気にしてたフロッピーディスクの時代なんて知らないでしょ？
//}

//imagetalkr[akina_nutoral]{
知らないです。名前は聞いたことありますが。
//}

//imagetalkl[mai_nutoral]{
私も父親が持ってたのを見たことあるだけだよ。容量8MBを重宝して持ち歩いてたなんて、今じゃ考えられないよね。
//}

//imagetalkr[akina_nutoral]{
そうですね。ってなると今は軽さは気にしなくてもいいんですか？
//}

//imagetalkl[mai_nutoral]{
昔と比べれば全然ってだけで今でもいろんな指標があるね。一つ一つ見ていこう。
//}

==== メモリ効率

//imagetalkl[mai_niko]{
まずはメモリ効率についてだ。コンピューターの3大構成要素のメモリのことだけど、覚えてるよね？
//}

//imagetalkr[akina_nutoral]{
はい。研修ではCPUが作業者、メモリが作業机、ディスクが本棚にたとえられてました。
//}

//imagetalkl[mai_niko]{
OK、じゃあ話は早いね。作業机は整理整頓されている方がいい。そうだよね。
//}

//imagetalkr[akina_nutoral]{
はい。
//}

//imagetalkl[mai_niko]{
沢山のプログラムが動く場合、一つ一つのプログラムが占有する机の面積は可能な限り少ない方がいいよね。
//}

//imagetalkr[akina_nutoral]{
そうですね。
//}

//imagetalkl[mai_ahaha]{
OK、以上！
//}

//imagetalkr[akina_eee]{
ええぇ！？それだけですか？
//}

//imagetalkl[mai_ahaha]{
うん。結論はもう出たしねぇ。あ、そうだ。どうやってメモリの使用量を減らすか、知りたい？
//}

//imagetalkr[akina_nutoral]{
それはもちろん知りたいです！
//}

//imagetalkl[mai_niko]{
よーし、メモリの使用量を減らす方法を洗い出してみよう。大きなものはこの三つだ。
内容と用途が重複する変数を使用しない
スコープが短すぎる変数を使用しない
データ量の多い変数を多用しない
//}

//imagetalkr[akina_ettu]{
「内容と用途が重複する変数を使用しない」って、単純に「無駄な変数を使わない」じゃダメなんですか？
//}

//imagetalkl[mai_nutoral]{
まぁ「無駄な変数を使わない」だと実際あやふやなのに強い言い方されてるようで嫌じゃない？だからこその具体的な言い方だね。
//}

//imagetalkr[akina_nutoral]{
なるほど。
//}

//imagetalkl[mai_uun]{
具体的な指摘をしないのに「君は無駄なコードを書きすぎだ」なんて言われたら嫌な気持ちにならない？
//}

//imagetalkr[akina_nutoral]{
それは嫌です。
//}

//imagetalkl[mai_nutoral]{
だよね。ま、その具体例ってだけだから「無駄な変数を使わない」って考えてもらってもいいよ。次の「スコープが短すぎる変数を使用しない」もその具体例の一つだ。
//}

//imagetalkr[akina_nutoral]{
スコープって何でしたっけ？
//}

//imagetalkl[mai_nutoral]{
本来は変数の使用可能な範囲っていう意味合いだけど、今回の説明では変数の寿命って言った方が早いかな。次の一行だけしか使われない変数くらいなら、省略表記で変数を定義しない書き方をしようねって話だ。
//}

//imagetalkr[akina_nutoral]{
具体的な例を教えてもらえますか？
//}

//imagetalkl[mai_nutoral]{
んー、めったに見ないけどこんな例がわかりやすいかも
//}


//cmd{

string userDisplayName = userName + userId.toString()
print(userDisplayName)
//}

//imagetalkl[mai_nutoral]{
このコード、違和感感じない?
//}

//imagetalkr[akina_nutoral]{
え、これは
//}

//cmd{
print(userName + userId.toString())
//}

//imagetalkr[akina_nutoral]{
でいいですよね。
//}

//imagetalkl[mai_nutoral]{
そうだね。その通り。こんなコードを実際のプロダクトで書く人は滅多にいないけど、究極はこれに尽きるね。
//}

//imagetalkr[akina_ettu]{
ちょっとシンプルすぎて参考にならないかもです。
//}

//imagetalkl[mai_nutoral]{
そうかもねぇ。でも言語仕様によるところもあるから基本方針しか示せないんだよねぇ。
//}

//imagetalkr[akina_ooo]{
そうなんですか。
//}

//imagetalkl[mai_nutoral]{
例えば、Pythonだと
//}

//cmd{
Array arr1 = [1,2,3,4,5]
Array arr2 = []
for elem in arr:
	arr2.push(elem*10)
print(arr2.toString())
//}

//imagetalkl[mai_nutoral]{
みたいなコードが
//}

//cmd{
Array arr1 = [1,2,3,4,5]
print(arr1.map(elem=>elem*10).toString())
//}

//imagetalkl[mai_nutoral]{
って書けちゃう。
//}

//imagetalkr[akina_eee]{
え⁉一行で？
//}

//imagetalkl[mai_ahaha]{
はじめはびっくりだよね。まぁそんなこともあって結局は「寿命の短い変数は使用しない」くらいに考えた方がいい。
//}

//imagetalkr[akina_ooo]{
結構あいまいなんですね。
//}

//imagetalkl[mai_nutoral]{
「無駄な変数は使わない」よりは具体的だから、参考までに覚えておこう。
//}

//imagetalkr[akina_niko]{
わかりました！
//}

//imagetalkl[mai_nutoral]{
3つめは「データ量の多い変数を使わない」ってやつだね。これはデータベースとのデータをやり取りするコード付近で起こりうる現象だね。データベースの特定テーブルに関連する大量データを丸ごと取ってくるコードがたまに存在する。
//}

//imagetalkr[akina_ettu]{
そんなことあるんですか？
//}

//imagetalkl[mai_ahaha]{
まあ、お客さんの要望で仕方なくやるケースもあるから一概には言えないけど、必要ないならやっちゃいけないことだね。
//}

//imagetalkr[akina_ooo]{
お客さんの要望ってケースもあるんですか。なるほど。
//}

//imagetalkl[mai_niko]{
状況に従って冷静に対処していこう。
//}

//imagetalkr[akina_niko]{
わかりました！
//}

==== ディスクI/O効率

//imagetalkl[mai_nutoral]{
データベースまわりの話も出てきたからディスクI/O周りの話もしよう。ディスクI/Oっていうのはディスクに対する書き込みや読み出しなどのアクセスの総称だね。現場で出会うケースとして「開発者の手元では問題が見つからなかったけど、実際に想定される使用回数を再現した負荷テストで予定していた性能が出なかった」というケースがある。こういうケースではデータベースとの接続数や検索条件など、プログラムから調整可能な範囲で性能が向上できることがある。
//}

//imagetalkr[akina_nutoral]{
前のプロジェクトではそこまで性能の話をされませんでしたが、そういう場面もあるんですね。
//}

//imagetalkl[mai_nutoral]{
BtoCのサービスになるとよく考えることがあるね。あとは金融系とかも性能に関してシビアなケースが多い。解決の糸口になるのはプログラムからデータベースへの接続数が限られている中でデータ内容がほとんど変わらない場所(マスター系データ)へのアクセスが頻発していたっていうケースが挙げられる。内容の変わらないアクセスが、データ内容が毎回異なるアクセスを邪魔してしまうっていう構造がよくあるケースだ。
//}

//imagetalkr[akina_nutoral]{
マスター系データですか。定数みたいな固定値をイメージすればいいですか？
//}

//imagetalkl[mai_niko]{
そうだね。ずっと変わらないデータや、一日とか一週間単位とかの長い時間をかけてデータが変わる場合も含めてマスター系と考えるのが良いね。
//}

//imagetalkr[akina_nutoral]{
なるほど。変わりにくいデータってことですね。
//}

//imagetalkl[mai_niko]{
そうそう。で、このような変わりにくいデータはキャッシュって言って、データをメモリ上に常駐させてディスクI/Oを発生させずにデータを提供する機能を使うことが慣習として定着してるね。
//}

//imagetalkr[akina_nutoral]{
定石があるんですね。それは安心です。でも、メモリに常駐させるっていうのはこれまで見てきた「データ量の多い変数を使わない」に引っかかったりしないんですか？
//}

//imagetalkl[mai_nutoral]{
マスター系データが大量過ぎるデータになることはあまり見ないね。仮にあったとしてもテーブル設計時点で注意して、テーブルを分割するように気をつけるべきだし、後からでも分割した方が良かったりするね。
//}

//imagetalkr[akina_ettu]{
あれ、後からってそれ「滝を遡る鯉」じゃないですか？
//}

//imagetalkl[mai_ahaha]{
あっはっは！その通りだねぇ。ウォーターフォールで出会いたくは無いね。たぶんアジャイルでも結構な修正作業になるだろうしね。
//}

//imagetalkr[akina_ugee]{
うう・・・頭が痛くなる・・・
//}

//imagetalkl[mai_nutoral]{
まぁ、こういうケースのためにプロジェクトでは作業量にバッファーを織り込むのが必要だね。
//}

//imagetalkr[akina_komari]{
そのときまでバッファーが残ってればいいですけど。
//}

//imagetalkl[mai_dahaha]{
ま、沼ったらそん時はそん時だ！友達にたくさん愚痴って心を軽くしよう！
//}

//imagetalkr[akina_komari]{
さすがに話聞いてもらいたくなります。
//}


//imagetalkl[mai_niko]{
そのぶん自分からも支えてあげればWIN-WINだね！朗らかにいこう！
//}

//imagetalkr[akina_komari]{
それはそれで、まいさんのつよつよメンタルがうらやましいです。
//}

=== 処理の早いプログラム

//imagetalkl[mai_nutoral]{
それじゃぁ、次は「処理の早いプログラム」について話していこう。といっても、多くの部分はこれまでの様々な観点と同じだね。
//}


//imagetalkr[akina_nutoral]{
読みやすかったり、メモリ効率のことを考えたコードなら多くの場合処理の早いコードになるってことですね。
//}

//imagetalkl[mai_niko]{
そう、特定の場合を除けば処理スピードを考えるまでに大体の条件は自然とクリアされているね。じゃぁ改めて、その特定の場合を洗い出してみよう。次の4つが主な項目だね。
1. ネストされたループ構文のネスト順
2. DBクエリにおいて外部結合する際の結合順
3. タスクを解決する有力な既存アルゴリズムの実装
4. 言語・フレームワークごとの最適なAPI使用
//}


==== ネストされたループ構文のネスト順

//imagetalkr[akina_nutoral]{
ネストってなんですか？
//}

//imagetalkl[mai_nutoral]{
直訳は「巣」だけど蜘蛛の巣ってイメージかな。for文の中にfor文があるみたいな、ループ構文や条件分岐構文の入れ子状態のことをネストっていうね。で、ここで注目したいのがネスト順、つまり二つ以上のループ構文がある時にループ対象にする要素数が少ないものから参照していくべき、って話だね。
//}

//imagetalkr[akina_nutoral]{
うーんと、要素が1000あるものと10あるものなら、10要素の方からループを回せ、てことでいいですか？
//}

//imagetalkl[mai_niko]{
いいね！すばらしい！ループがbreak文を含むかどうかにかかわらず、可能であれば要素の少ないものから回すべきだね。そのコード部分が呼ばれれば呼ばれるたびにタイムロスが発生するからね。
//}


==== DBクエリにおいて外部結合する際の結合順

//imagetalkr[akina_nutoral]{
もしかして、2つ目の「DBクエリにおいて外部結合する際の結合順」も似たような話ですか？
//}

//imagetalkl[mai_niko]{
そうだね！たまにDBクエリ文の効率に関してまで思考を割かない人がいるけれど、可能な限り気を配っていった方がいいね。ただ、DBクエリに関してはロジック上どうしても要素数の多いテーブルから走査しなきゃいけないこともあるから状況による部分が多いね。
//}

//imagetalkr[akina_nutoral]{
なるほど、気を付けます。
//}

==== タスクを解決する有力な既存アルゴリズムの実装

//imagetalkr[akina_nutoral]{
3つ目の「タスクを解決する有力な既存アルゴリズムの実装」って、どういうことですか？そんなアルゴリズムがあるならライブラリですでに実装されている気がしますが・・・
//}

//imagetalkl[mai_nutoral]{
ライブラリがあるなら最優先で使いたいね！要はそれを見落とさない調査力と、実装ライブラリが無い場合にもアルゴリズムに従って実装した方が結果的に処理が早くなるってことだね。
//}

//imagetalkr[akina_nutoral]{
なるほど。実装するのは少しハードルが高そうです・・・
//}

//imagetalkl[mai_nutoral]{
まぁ、大体ライブラリがあるから安心していいよ！ただ、言語ごとにライブラリが豊富な分野が分かれているから言語やフレームワークの選定が間違ってると痛い目を見るね。
//}

//imagetalkr[akina_komari]{
私みたいな現場のプログラマからしたら祈るしかない気がします
//}

//imagetalkl[mai_niko]{
まぁ、そういうときのために私みたいな下流と上流を兼ねる中堅がいるからね！不安になったらいつでも読んで！
//}

//imagetalkr[akina_niko]{
はい！よろしくお願いします！
//}


==== 言語・フレームワークごとの最適なAPI使用

//imagetalkl[mai_nutoral]{
じゃ、言語やフレームワークの仕様に関して話が広がったことだし4つ目の「言語・フレームワークごとの最適なAPI使用」についてだ。簡単に言うとループ構文や条件分岐構文などがフレームワークごとに用意されていることがあって、フレームワーク側の書き方が早い場合や遅い場合があるから気を付けようって話だ。
//}

//imagetalkr[akina_ettu]{
速いのも遅いのもあるんですか！？見分けるのが大変そうです。
//}

//imagetalkl[mai_nutoral]{
有名なフレームワークならたいていの場合比較結果がネットに載ってるね。仮に載っていなかったとしても、調べるのはプロダクト全体での性能評価のタイミングが多いから一人だけでやることはないからそこまで心配しなくていいよ。
//}

//imagetalkr[akina_niko]{
そうなんですか！よかった～。
//}

//imagetalkl[mai_nutoral]{
万が一、やることになった場合は1000回~10万回とかのオーダーで実験して報告書作ってお客さんに説明してプロジェクト全体でコード修正していく流れになるね。
//}

//imagetalkr[akina_ugee]{
か・・・解像度が高い・・・もしかして・・・
//}

//imagetalkl[mai_ahaha]{
さ！次いこ次！
//}

//imagetalkr[akina_eee]{
（ひぇ～～)
//}

== 信頼性の高いプログラム

//imagetalkl[mai_nutoral]{
次の話題は「信頼性の高いプログラム」だ。ズバリ、テストがしっかり作られていて成功することが約束されているプログラムだね。
//}

//imagetalkr[akina_komari]{
んん？テストが書かれているなら、成功することは当然な気がします。
//}

//imagetalkl[mai_nutoral]{
そうだね。問題はいかに実際の動きに即した意義のあるテストをつくるか、だね。
//}

//imagetalkr[akina_nutoral]{
なるほど、テストの切り出し方が難しいってことですね。
//}

//imagetalkl[mai_nutoral]{
そう、そして悲しいことにそもそも「テストが作りづらい」プログラムが存在する。
//}

//imagetalkr[akina_eee]{
ええ！？テストできなきゃどうやって信頼性を証明するんですか？
//}

//imagetalkl[mai_niko]{
そもそも、テストが作りやすいプログラムが「良いプログラム」の条件なんだ。そしてそれをどうやって作るかが注目すべき観点だね。
//}

//imagetalkr[akina_hee]{
なるほど、テストを作りづらいプログラムはそもそも作らないことが理想なんですね。
//}

//imagetalkl[mai_nutoral]{
そうそう！その前提が大事なんだよね！
//}

=== テスト可能なプログラム

//imagetalkl[mai_nutoral]{
テスト可能なプログラム、もといテストが作りやすいプログラムの特徴は主に以下の4点に集約される。自分が実装するときにはこれらに気を付けながら実装しよう。
1. シンプルな目的のための処理を行う
2. 内部変数の状態に依存しない
3. 入力変数以外の値に依存しない
4. 処理結果を出力に指定する
この4つだ。
//}

//imagetalkr[akina_nutoral]{
どれもいまいちピンとこないです。
//}

//imagetalkl[mai_nutoral]{
そうだね、一つ一つ詳しく見ていこう。
//}

==== シンプルな目的のための処理を行う

//imagetalkl[mai_nutoral]{
これはテストを行う以前の話ではあるんだけど、そもそも一つ、もしくは少ない目的のためのプログラムを書こうという話だね。
//}

//imagetalkr[akina_nutoral]{
今まで学んできた中で自然と達成されている気もしますが、テストにも関係するんですね。
//}

//imagetalkl[mai_niko]{
そう、目的が複数あったりするだけでテスト条件や出力結果のパターンが爆発的に増える。テストコードをたくさん書く必要が出てくるし、書く側も読む側も今何のテストをしているのかがわからなくなってしまうことがあるんだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、ここでも書きやすさと読みやすさが出てくるんですね。でも確かに、何のためのコードかがわかっている方がテストも書きやすい気がしますし、出来上がったテストコードも読みやすいのは納得です。
//}


==== 内部変数の状態に依存しない

//imagetalkl[mai_nutoral]{
テストコードが何かしら関数のテストを行うものだとすると、基本的に出力結果は入力の値にのみ影響を受けるべきだ。ここで「内部変数の状態に依存しない」というのは入力値以外で関数及びクラス内で持っている変数の値によって期待する出力が変わらない設計のことを言うんだ。たとえば車というクラスがあったとして、アクセルに該当する関数があったとしよう。アクセル関数の出力は車のエンジンの回転数だとして、基本的にアクセル関数の出力はアクセルを踏み込む力に影響されるという設定だ。
//}

//imagetalkr[akina_ooo]{
なるほど、車のアクセルですか。あれ、待ってください。オートマ車ならその説明で良いですが、マニュアル車ならギア数で車の加速の仕方が違いますよね。
//}

//imagetalkl[mai_niko]{
いい着眼点だ。そのとおり、そして今回の話ではオートマ車のような設計にしようという話だね。
//}

//imagetalkr[akina_nutoral]{
なぜでしょう？
//}

//imagetalkl[mai_nutoral]{
テストを実行するときの条件は入力だけに絞られた方が、テストを書きやすいし読みやすい。今回の例だと、マニュアル車の場合、テストの条件にアクセル関数の入力以外にギアの状態も含めなければならなくなる。
//}

//imagetalkr[akina_nutoral]{
なるほど。でもテストが不可能なわけではないんですね。
//}

//imagetalkl[mai_nutoral]{
そうだね。「内部変数の状態に依存しない」という縛りを外れるというだけならテストを書くことは可能だ。ただテストケースが非常に多くなりやすく、そのぶんテストケースを見逃すことも起こりやすい。その点、テストの設計がしにくいっていうとしっくりくるかもね。
//}

//imagetalkr[akina_ooo]{
テストケースを洗い出すのが難しいんですか。それは避けたいですね。
//}

//imagetalkl[mai_niko]{
いい理解だね！ただ、どうしても関数の目的や作りによっては内部変数に依存せざるを得ないこともある。そういう場合は慎重にテストケースを洗い出し、漏れなく実装するように心がけよう。
//}

//imagetalkr[akina_nutoral]{
わかりました！
//}

==== 入力変数以外の値に依存しない


//imagetalkr[akina_nutoral]{
「入力変数以外の値に依存しない」っていう項目も今のと似てますね。意味的にも同じですか？
//}

//imagetalkl[mai_uun]{
うー－ん、意味的には似てるんだけど、より厳しい制約だね。これに関してはほぼ絶対「やってはいけない」項目だ。
//}

//imagetalkr[akina_ettu]{
そうなんですか？
//}

//imagetalkl[mai_nutoral]{
この縛りを外れることを良しとしてしまうとテストケースが煩雑になりすぎて収集がつかなくなる。ほとんど「テスト不可能」な状態になってしまうんだ。
//}

//imagetalkr[akina_nutoral]{
テスト不可能ですか、それは怖いです。
//}

//imagetalkl[mai_uun]{
ごく稀なケースとして、システムの環境変数やプログラム全体で参照する定数によって挙動を変えることを求められるコードとかが存在するけど、許されるのはそれぐらい。実行コード中にメモリに乗るだけの変数の影響を受ける設計は言語道断だね。私が見つけたなら小一時間説教するよ。
//}


//imagetalkr[akina_eee]{
ひぇ～、そんなにですか。
//}

//imagetalkl[mai_uun]{
実際のプロジェクトの被害を考えたら一時間なんて安い方だよ・・・まったく、なんか思い出してイライラしてきた。
//}

//imagetalkr[akina_ettu]{
お、落ち着いてください。今怒ってもどうにもならないですよ。
//}

//imagetalkl[mai_ahaha]{
うん、そうだね。忘れよ忘れよ。ありがと！
//}

==== 処理結果を出力に指定する


//imagetalkl[mai_nutoral]{
それじゃ次は「処理結果を出力に指定する」だ。
//}

//imagetalkr[akina_nutoral]{
これだけ否定形じゃないんですね。
//}

//imagetalkl[mai_nutoral]{
まぁ、これは状況にもよるから努力目標だね。テストコードの記述において、出力に影響する条件のパターンが増えることは大きな負担だけど、出力結果のパターンが増えることはそこまで負担にならないからね。
//}

//imagetalkr[akina_nutoral]{
そうなんですか。あ、でもなんとなくわかるかもしれません。テストコードの書き方的にほとんど同じ条件記述から別々の出力パターンの確認をしていた気がします。
//}

//imagetalkl[mai_nutoral]{
言語やフレームワークによっては類似した条件記述をまとめたり暗黙的にコピーしたりするテストの記述方法もあるからね。プログラムの処理結果が出力に来ることでテストの書き方は圧倒的に楽になるけど、出力に来なくても関連する変数の参照で結果を確認できるならそこまで致命的なロスにはならないね。
//}

//imagetalkr[akina_nutoral]{
なんだか意外です。処理の結果は出力に出すって言葉が自然過ぎて例外が許されやすいイメージじゃなかったので。
//}

//imagetalkl[mai_nutoral]{
そうだね。まぁ意味もなく処理結果を出力に返さないようなことはするなってぐらいだね。テストを書く人への配慮ってわけだ。
//}

//imagetalkr[akina_nutoral]{
テストを書くのが自分だったらサボっちゃいそうです。
//}

//imagetalkl[mai_niko]{
そうさせないための注意書きだね！自分相手でも必要がなければ処理結果は出力に出す。肝に銘じよう！
//}

//imagetalkr[akina_niko]{
はい。気を付けます！
//}

=== テストケースが必要十分なプログラム


//imagetalkl[mai_nutoral]{
さて、次は「テストケースが必要十分なプログラム」だけどこれはとっても複雑で入り組んだ話題だ。
//}

//imagetalkr[akina_nutoral]{
そうなんですか？でもたしかに、何を持って必要十分かなんて全然イメージわかないです。
//}

//imagetalkl[mai_nutoral]{
ほんとに、この「必要十分」っていうのが厄介なんだ。でも、覚えておいてほしいのは「完璧」でなきゃいけないわけじゃないってことだね。
//}

//imagetalkr[akina_nutoral]{
「完璧」を目指す物なんじゃないですか？
//}

//imagetalkl[mai_nutoral]{
まぁ完璧の定義にもよるけど、そもそもプログラムに「バグはなくならない」っていう考え方が広く提唱されているね。
//}

//imagetalkr[akina_eee]{
えぇ！？
//}

//imagetalkl[mai_nutoral]{
より詳しく説明すれば、プログラムにバグはなくならないけどテストを重ねることによって致命的なバグは取り除くことができるっていう意味だね。
//}

//imagetalkr[akina_nutoral]{
うわぁ、良かった。びっくりしました。
//}

//imagetalkl[mai_niko]{
前提がそもそもバグの存在を認めることで、バグの潜みやすい部分を洗い出して対処していくスタイルの宣言って思ってもらえればいいね。私もこの考えには賛成だ。
//}

//imagetalkr[akina_niko]{
まぁ、言われてみればそうとらえた方が前向きにテストコードを作れる気がしますね。私も賛成です！
//}

=== テストの広さ

//imagetalkl[mai_niko]{
まずはテストの必要十分条件を埋めるための「テストの広さ」を見ていこう。
//}

//imagetalkr[akina_nutoral]{
「広さ」ですか。網羅性ってヤツですか？
//}

//imagetalkl[mai_nutoral]{
うーん、網羅性って言葉はテスト関連の言葉だと別の意味でとらえられやすいから、いったん「広さ」で考えてもらった方がいいかも。単純に種類の多さ、だね。
//}

//imagetalkr[akina_nutoral]{
なるほど、わかりました。
//}

//imagetalkl[mai_niko]{
よーし、じゃあテストの種類について説明していこう。次の5種類が主に話題にあがるね。
1. 単体テスト
2. 内部結合テスト
3. 外部結合テスト
4. システムテスト
5. ユーザー受け入れテスト
この5つだ。
//}

//imagetalkr[akina_ooo]{
単体テストは経験がありますが、そんなに種類があるんですね。
//}

//imagetalkl[mai_nutoral]{
この５種類は最低限抑えたいね。ただ、正直なところ私はこの分け方に納得いってない。
//}

//imagetalkr[akina_ettu]{
え？そうなんですか？
//}

//imagetalkl[mai_uun]{
いろんな現場をまたいで仕事をしてると現場ごとに単体テスト、内部結合テスト、外部結合テストは定義やテスト範囲がバラバラなんだ。
//}

//imagetalkr[akina_eee]{
えぇ！？でもこういう分類されているのっていろんな経験を積んだ人たちが集まって決めているんじゃないですか？
//}

//imagetalkl[mai_nutoral]{
分類を決めたときはそうだね。逆に言えば分類の穴というか定義漏れに引っかかる部分が現場に多すぎて結局現場の実情の方に解釈が曲げられていってしまっているんだ。
//}

//imagetalkr[akina_komari]{
うーん、決めた側が悪いのか、現場が悪いのか。
//}

//imagetalkl[mai_nutoral]{
私は決めた側、というか決めた内容が良くないと思ってるよ。
//}

//imagetalkr[akina_ooo]{
おぉ、言いきっちゃうんですね。
//}

//imagetalkl[mai_niko]{
まずはスタンスを決めてから意見を述べたほうが周囲も理解しやすいってもんだ。
//}

//imagetalkr[akina_komari]{
それは確かにそうですけど・・・
//}

==== 単体テスト

//imagetalkl[mai_nutoral]{
それじゃあまずは単体テストについてだ。これは基本的にテスト対象のプログラムに対してのみテストを行えるようなテストのことを言うね。
//}

//imagetalkr[akina_nutoral]{
いきなりふわっとしてますね。テスト対象に対してのみテストをするって、すべてのテストがそうだと思うんですが。
//}

//imagetalkl[mai_uun]{
うーんそうだねぇ、ごめんねぇ。でも様々な現場を見るとこれぐらいの言葉じゃないとまとめられないんだよね。ちなみに、単体テストのことを「テスト対象のクラスもしくは関数に対するテストであり、非テスト対象をすべてスタブに置き換えてテストを行う」っていうものだと主張する人たちもいる。私はこういう主張を単体テスト原理主義って呼んでる。
//}

//imagetalkr[akina_ettu]{
すべてスタブに置き換える・・・?ってすみません、スタブってなんでしたっけ？
//}

//imagetalkl[mai_nutoral]{
入力とかに使われるクラスなどをテスト用のクラスに置き換えることをイメージしてもらえるといいかも。偽物というか代替物って考えてもらってもいいね。
//}

//imagetalkr[akina_nutoral]{
偽物を使うんですか、現物ではなく。
//}

//imagetalkl[mai_niko]{
そう、テストに関係あるもののみに関心を集めるためにできるだけ機能性を落として表面をなぞるだけの代替物だ。スタブを作ったのにスタブ自身がバグの温床になるのはタブーだからね。
//}

//imagetalkr[akina_hee]{
なるほど、スタブを作るのはあくまでもテスト対象にのみ関心を絞るためですね。でも、そんな偽物を使って実際の機能のテストができるんですか？
//}

//imagetalkl[mai_nutoral]{
確かに心配だよね。ちなみに単体テスト原理主義の人たちはそのような偽物を使わないテストのことを内部結合テストと呼ぶね。
//}

//imagetalkr[akina_komari]{
なんか言い方が引っかかりますね。その単体テスト原理主義の人たち以外はなんて言ってるんですか？
//}

//imagetalkl[mai_nutoral]{
スタブを使った粒度の細かいテストに加えて、スタブを使わずに複数クラスの現物を使ったテストのことも、その目的の分類によって単体テストって呼んでるね。
//}

//imagetalkr[akina_nutoral]{
もうすでに意見が割れてるんですね。
//}

//imagetalkl[mai_nutoral]{
そう、ややこしいよね。この複数クラスのテストをどのテスト区分に当てはめるかは現場ごとに違うんだ。まぁでも一旦次の粒度のテストの話に入ろう。
//}

==== 内部結合テスト

//imagetalkr[akina_ettu]{
「内部結合テスト」ってその次の「外部結合テスト」と字面が近いように思えますが、何が違うんですか？
//}

//imagetalkl[mai_nutoral]{
これもまた現場によって違うんだよね。よく言われるのは「内部結合テスト」はサーバーや開発対象サービス単位のテスト、「外部結合テスト」は複数の機能を持つサーバーやサービス間の連携を確認するテストって分け方だね。
//}

//imagetalkr[akina_nutoral]{
なるほど、私のこの間のプロジェクトも他社が連携先のサービスを作っていて、それと連携するテストをしているっていう話は聞きました。自分たちの担当するサブシステムのテストが内部結合テストなんですね。
//}

//imagetalkl[mai_niko]{
サブシステム、その言い方は良いね。大体の場合そう考えてもらっていいと思うよ。
//}

//imagetalkr[akina_nutoral]{
またふわっとしてますね。この定義にも何か問題があるんですか？
//}

//imagetalkl[mai_nutoral]{
ある。大いにある。
//}

//imagetalkr[akina_nutoral]{
大いに、ですか。いったい何があるんですか？
//}

//imagetalkl[mai_nutoral]{
そもそも、この内部結合テストの定義を許容すると、「内部結合テスト」っていう目的のテスト項目が多すぎるんだ。
//}


//imagetalkr[akina_ettu]{
そんなに多いんですか？
//}

//imagetalkl[mai_nutoral]{
多いね。さっきの単体テスト原理主義の人たちによれば、複数クラスをつなげたテストはすでに内部結合テストだ。それに加えてWEB開発であればWebAPI単位のテストも含まれる。さらに考えなきゃいけないのが、GUIなどの画面要素のテストや、GUIの操作を模擬的に行うテストだ。
//}

//imagetalkr[akina_nutoral]{
なるほど、確かに多いですね。単体テストの次はすぐAPIや画面単位のテストにまで視野を広げることになるんですね。内部ロジックのテストがしっかりできているか心配です。
//}

//imagetalkl[mai_nutoral]{
そうなんだよ。APIテストが通るなら複数クラスを繋げたテストも通るはずだから複数クラスを繋げたテストを行わないっていう主張も存在するくらいだからね。
//}

//imagetalkr[akina_ettu]{
それはなんだか・・・暴論のような気がします。そもそもAPIの形に整えるまでバグへの対応ができないことになっちゃいます。
//}

//imagetalkl[mai_uun]{
だよねぇ。私もそう思うんだけど、現場の一部の人から「その範囲のテストはお客様にわかるように説明できる内容ではなく、そのような内容をテスト成果物として納品するわけにはいかないからテスト対象にはしない」とかなんとか言われてテストの設計すらさせてもらえなかったんだよね。しかも一回だけじゃない、いろんな現場で。
//}

//imagetalkr[akina_komari]{
うぅ・・・たしかにお客さんは分からないかもしれないですけど、「成果物に挙げられないから」ってそれはテストを行う思想そのものと相反してる気がします。
//}

//imagetalkl[mai_niko]{
だよねぇ！私もそう思うんだ。テストを行う元の思想は「品質を上げる」ってことだからね。仮に何かのテストを人的リソースの問題で切り捨てるにしても重要なのはリソースと品質のバランスであって「報告のしやすさ」ではないと思うんだよねぇ。
//}

//imagetalkr[akina_nutoral]{
私もそう思います。
//}

//imagetalkl[mai_nutoral]{
あ、ちなみに開発するシステムが単体のサーバーやサービスで完結する場合、GUIの操作を模擬的に行うテストなんかは「外部結合テスト」に位置づけるプロジェクトもあるね。
//}

//imagetalkr[akina_ugee]{
うぇ・・・ここでも定義のブレがあるんですか。
//}

//imagetalkl[mai_uun]{
ブレてばっかりだよ。まぁ厳密に見ればWEBページを提供するサーバー、DBサーバー、APIサーバーも一つのサービスを提供するために連携しているから、WEBページサーバーとAPIサーバーの開発メンバーが違えば「外部結合テスト」と言いたくなる気持ちもわかるよ。
//}

//imagetalkr[akina_ooo]{
なるほど・・・奥が深いですね
//}

==== 外部結合テスト

//imagetalkl[mai_nutoral]{
じゃ、気を取り直して次は「外部結合テスト」だ。これは多くの場合サブシステム間の連携を確認するテストだ。よく言われるのは実際に使うユーザーの操作順を想定したシナリオテストって言われるものを行うね。
//}

//imagetalkr[akina_nutoral]{
シナリオですか。時系列に沿ったサービスの挙動を確認するんですね。
//}

//imagetalkl[mai_nutoral]{
そうだね！それ以外にも想定しない操作をしたらちゃんと警告などを表示するかどうかとか、どれかのサブシステムがダウンしたときにユーザーに説明できる表示ができるか、なんてこともテストするね。
//}

//imagetalkr[akina_nutoral]{
画面表示を含めたテストってことですか？
//}

//imagetalkl[mai_nutoral]{
画面を含むけど、ユーザーの操作とそれへのサービスの反応っていう点に着目してるね。なかでも特に機能面を確認することが多い。
//}

//imagetalkr[akina_nutoral]{
なるほど、想定していた通りの動きをするかどうか、という感じですね。
//}

//imagetalkl[mai_niko]{
うんうん。作っているものが想定とあっているかをテスト項目とテスト結果を持ってお客さんに説明していくのがこのフェーズのゴールだね。機能がもし想定と違ったら・・・プロジェクトのリソースが余っていれば一部作り直しになるわけだ。
//}

//imagetalkr[akina_ugee]{
大変そう・・・。
//}

//imagetalkl[mai_nutoral]{
そもそも要件定義書に書かれた機能の定義からやり直さなきゃいけないからね。めちゃくちゃ大変だ。というかこのあたりで差し戻しがあるとアジャイルでいうスプリント単位の開発が始まるというか、毎日報告して状況確認しながら必死でモノづくりをしなきゃいけなくなるんだよね。実はこれがデイリースクラムの開発手法に似ていたりする。残業の有無は別だけど。
//}

//imagetalkr[akina_nutoral]{
もしかしてスクラムとかアジャイルってこういうところから生まれてるんですか？
//}

//imagetalkl[mai_uun]{
どうだろうねぇ、明確なゴールがあって、マネージャーは毎日進捗を確認して、開発者はことあるごとに報告を求められて短期で開発からテストまでを行う・・・。緊急時にそのやり方をするなら、最初からそのやり方で余裕を持ってやればいいのにって思うよ。
//}

//imagetalkr[akina_ugee]{
・・・私もそう思います。
//}

==== システムテスト

//imagetalkl[mai_nutoral]{
さてさて、「外部結合テスト」でお客さんがほしいものが出来上がりそうだ、ってなったら次は何をするか。答えは実際の使用量に耐えうる作りになっているかを確認する「システムテスト」だ。
//}

//imagetalkr[akina_ooo]{
使用量に耐えうる・・・たくさんアクセスが来た時にどうなるか、ですか？
//}

//imagetalkl[mai_nutoral]{
そうだね。ユーザー使用量に起因する負荷を確認する「負荷テスト」や何らかの理由でサブシステムのどれかがダウンした際に、再復旧までの時間などが仕様に合っているかの確認を「ダウン・リスタート(DR)テスト」などを行うね。
//}

//imagetalkr[akina_hee]{
なるほど、やりたいこととは別に、それが使える状態になっているかのテストですね。
//}

//imagetalkl[mai_niko]{
そうそう、「負荷テスト」の中には想定利用数の秒間リクエスト数が行われた際にどうなるか、と想定を超えるリクエストが置き続けた際にどのような挙動になるかをテストするね。
//}

//imagetalkr[akina_ooo]{
たくさんリクエストを送るのは手動は大変そうですが、何か専用のプログラムを作るんですか？
//}

//imagetalkl[mai_nutoral]{
一応だけどJMeterっていうのをはじめとして負荷テスト用のツールもいくつか存在するよ。ちなみにAPIの設計がテストしやすいものじゃなかったらこれらのツールの導入にも一苦労だ。
//}

//imagetalkr[akina_ooo]{
テストのしやすさって本当に重要なんですね。
//}

//imagetalkl[mai_niko]{
そうだね!で、この性能テストで性能が十分に発揮されないと、プログラムやDBクエリ条件、DB接続設定等を変更して想定に近くなるまで調整する。これを「チューニング」って言うね。
//}

//imagetalkr[akina_nutoral]{
楽器のチューニングに近いイメージですかね。
//}

//imagetalkl[mai_nutoral]{
まぁそんなものだね。どれだけ良い機能でも、速いもの勝ちでしか気持ちよく使えないのはよくないからね。あとは災害などでサーバー群が機能停止した際にどれくらいの復旧時間が必要かを想定してお客さんと合意するっていうのも重要だね。要件定義時点で合意は取ってるはずだけど、もしも要件定義に性能の指定が無ければここで再度確認しなきゃだね。
//}

//imagetalkr[akina_eee]{
ひぇ～また巻き戻るんですか。
//}

//imagetalkl[mai_nutoral]{
ここまで来てるとプロジェクトに数千万以上のお金がかかってることがあるから、お客さんと妥協点を見つけてリリースするっていうのがよく見るケースだね。がっつり開発までサイクルを戻す例は一回だけ見たことある。
//}

//imagetalkr[akina_nutoral]{
きつくなかったですか？
//}

//imagetalkl[mai_uun]{
地獄だったね。
//}

//imagetalkr[akina_ugee]{
ひぃ～！
//}


==== ユーザー受入テスト

//imagetalkl[mai_nutoral]{
さて、テストの広さに関する最後の項目は「ユーザー受入テスト」だ。これは実際のユーザーが操作してその使用感や感想などをフィードバックしてもらう、「フィードバックテスト」がその多くを占めるね。あとは予期しない操作を探すために適当に触ってもらう「モンキーテスト」なんてものも行ってもらう。
//}

//imagetalkr[akina_nutoral]{
モンキーテストですか。本当に適当に触るんですかね？
//}

//imagetalkl[mai_nutoral]{
可能なら、シナリオテストをする人とは別に、何も知らされていない状態でとにかく触ってみるっていう人にお願いしたいね。これで軽微なバグやそもそもの仕様バグが見つかることも多い。
//}

//imagetalkr[akina_eee]{
そんなにバグが見つかっちゃっていいんですか？
//}

//imagetalkl[mai_nutoral]{
致命的な物はほとんど見つからないのが私が見てきた所感かな。画面の細かい部分の文字とか「説明文が分かりにくい」とか数字の入力欄に日本語を入れて「こういうエラー文が表示されるの分かりにくいです」とかいうのを探していく。
//}

//imagetalkr[akina_nutoral]{
粗探しみたいですね。
//}

//imagetalkl[mai_niko]{
見つかるのが「粗」だけなら計画は順調だね！修正に時間がかかりそうなものは次のバージョンがあがる際の内容に繰越したりを考えることになるケースが多いね。
//}

//imagetalkr[akina_nutoral]{
なるほど、でもこれでやっとお客さんのもとに安心して送り届けられますね！
//}

//imagetalkl[mai_nutoral]{
そうだね！これまで説明してきたテストをしっかりやってるプロジェクトはお客さんからの信頼も高くなるし、会社としても表彰対象になることもあるね。
//}

//imagetalkr[akina_niko]{
いいですね！
//}

//imagetalkl[mai_nutoral]{
大体のプロジェクトではユーザー受け入れテストでテストを終了し、開発プロジェクトの終了をするのがほとんどだけど、リリース後も新機能があった方がいいかを本番サーバーに実装してユーザーの挙動を見て確認する「A/Bテスト」や、コード変更後に内部結合テストなどを実行して既存コードに影響するバグが出ないことを継続的に確認する「リグレッションテスト」っていう分類もあるね。
//}

//imagetalkr[akina_nutoral]{
本当にいろいろあるんですね。勉強してみます！
//}

=== テストの深さ

//imagetalkl[mai_nutoral]{
ここまではどのような種類のテストがあるかを見てきたけど、今回はどのようなテストを書けば信頼性を保てるかを考える「テストの深さ」の話を見ていこう。まずはブラックボックステストだ。
//}

//imagetalkr[akina_nutoral]{
ブラックボックスですか、中身の挙動が分からない、という意味ですか？
//}

//imagetalkl[mai_niko]{
そうだね！経験はあるかな？
//}

//imagetalkr[akina_nutoral]{
おそらくあります。この間のプロジェクトはブラックボックステストもホワイトボックステストもやったはずですので。でも違いをはっきり説明できるほど覚えていません。
//}

//imagetalkl[mai_nutoral]{
ＯＫ、一つずつ見ていこう。
//}